# sort()方法

## 功能

按照一定的规则重新排序原数组

## 返回值

排序后的原数组

## 参数

### 不传递参数

数值参数会先被转化成字符串，再按照字典序去排列（ASCII码排序）

```js
const arr1 = ['c', 'd', 'C', 'a', 'D']
const res1 = arr1.sort()
console.log(res1) // ['C', 'D', 'a', 'c', 'd']
console.log(arr1) // 该方法会改变原数组 ['C', 'D', 'a', 'c', 'd']
```

```js
const arr2 = [6, 9, 1, 5, 3, 2]
const res2 = arr2.sort()
console.log(res2) // [1, 2, 3, 5, 6, 9]
console.log(arr2) // [1, 2, 3, 5, 6, 9]
```

```js
const arr3 = [6, 9, 1, 'c', 'd', 'C', 'a', 'D', 5, 3, 2]
const res3 = arr3.sort()
console.log(res3) // [1, 2, 3, 5, 6, 9, 'C', 'D', 'a', 'c', 'd']
console.log(arr3) // [1, 2, 3, 5, 6, 9, 'C', 'D', 'a', 'c', 'd']
```

```js
const arr4 = [1011, 11, 1101, 10011]
const res4 = arr4.sort() // ASCII码排序
console.log(res4) // [10011, 1011, 11, 1101]
console.log(arr4) // [10011, 1011, 11, 1101]
```

### 接收回调函数为参数

#### 回调函数的返回值

定义排序顺序的函数，返回值是一个数字

1. 如果返回值为正数，则`arg1`位于`arg2`之前
2. 如果返回值为0，则`arg1`和`arg2`不交换位置
3. 如果返回值为负数，则`arg2`位于`arg1`之前

#### 回调函数的参数

`arg1`：[arr[1], ..., arr[arr.length - 1]]
`arg2`：[arr[0], ..., arr[arr.length - 2]]

```js
const arr5 = [6, 9, 1, 5, 3, 2]
const res = arr5.sort(function(arg1, arg2) {
  console.log('arg1：', arg1, 'arg2：', arg2)
})
/* 
  arg1： 9 arg2： 6
  arg1： 1 arg2： 9
  arg1： 5 arg2： 1
  arg1： 3 arg2： 5
  arg1： 2 arg2： 3
*/
```

```js
const arr7 = [6, 9, 1, 5, 3, 2]
const res7 = arr7.sort(function(arg1, arg2) {
  return 1
})
console.log(res7) // [6, 9, 1, 5, 3, 2]
```

## 排序用法

1. 返回值为正数或0，数组顺序不变

```js
const arr6 = [6, 9, 1, 5, 3, 2]
const res6 = arr6.sort(function(arg1, arg2) {
  return 1
})
console.log(res6) // [6, 9, 1, 5, 3, 2]
```

2. 返回值为负数，数组完全颠倒

```js
const arr7 = [6, 9, 1, 5, 3, 2]
const res7 = arr7.sort(function(arg1, arg2) {
  return -1
})
console.log(res7) // [2, 3, 5, 1, 9, 6]
```

3. 升序排序

```js
const arr8 = [6, 9, 1, 5, 3, 2]
const res8 = arr8.sort(function(arg1, arg2) {
  return arg1 - arg2 // return 参数1 - 参数2：为升序排序
})
console.log(res8) // [1, 2, 3, 5, 6, 9]
```

4. 降序排序

```js
const arr9 = [6, 9, 1, 5, 3, 2]
const res9 = arr9.sort(function(arg1, arg2) {
  return arg2 - arg1 // return 参数2 - 参数1：为降序排序
})
console.log(res9) // [9, 6, 5, 3, 2, 1]
```

5. 数组对象排序

```js
const arr10 = [
  { name: '张三', score: 90 },
  { name: '李四', score: 100 },
  { name: '王五', score: 50 },
  { name: '赵六', score: 80 }
]
const res10 = arr10.sort(function(arg1, arg2) {
  return arg1.score - arg2.score // 根据score升序排序，降序同理
})
console.log(res10)
/*
 * [
 *   { name: '王五', score: 50 },
 *   { name: '赵六', score: 80 },
 *   { name: '张三', score: 90 },
 *   { name: '李四', score: 100 }
 * ]
 * */
```

## 注意

该方法会改变原数组

# forEach()方法

## 功能

遍历数组，数组的所有元素都会被依次传入到回调函数中进行处理

## 返回值

undefined

## 参数

参数1：回调函数
参数2：用来绑定回调函数内部的this

### 回调函数的参数

`item`：数组中的元素
`index`：数组元素的索引
`arr`：被遍历的数组

> 注意：这三个参数不论写不写，都会被自动传入回调函数中，可以从`arguments`中获取到

```js
const arr = ['a', 'b', 'c']
arr.forEach(function() {
  console.log(arguments)
})
```

[![pAVYHi9.png](https://s21.ax1x.com/2024/09/02/pAVYHi9.png)](https://imgse.com/i/pAVYHi9)

> 注意：arguments只能在普通函数中使用，不能在箭头函数中使用（箭头函数中没有arguments对象）

```js
const arr = ['a', 'b', 'c']
arr.forEach(function(item, index, arr) {
  console.log(item) // TODO:删除log
  console.log(index) // TODO:删除log
  console.log(arr) // TODO:删除log
})
/*
 * a
 * 0
 * ['a', 'b', 'c']
 * b
 * 1
 * ['a', 'b', 'c']
 * c
 * 2
 * ['a', 'b', 'c']
 * */
```

## 遍历用法

1. 通过`参数2`改变回调函数的this指向，实现两个数组之间的操作

```js
const arr = ['a', 'b', 'c']
const arr2 = []
arr.forEach(function(item, index, arr) {
  this[index] = item + item
}, arr2)
console.log(arr) // ['a', 'b', 'c']
console.log(arr2) // ['aa', 'bb', 'cc']
```

## 注意

1. 由于forEach中的回调函数是自己调用的，所有它的this应指向window

```js
const arr = ['a', 'b', 'c']
arr.forEach(function(item, index, arr) {
  // arr[index] = item + item // ['aa', 'bb', 'cc']
  // this[index] = item + item // ['a', 'b', 'c']
  console.log(this) // Window { ... }
})
console.log(arr)
```

2. 原始值这种修改不能改变原数组，引用值这种修改可以改变原数组

```js
const arr = ['a', 'b', 'c']
arr.forEach(function(item, index) {
  item = item + item // 原始值这种修改是不能改变原数组的
  // arr[index] = item + item // ['aa', 'bb', 'cc']
})
console.log(arr) // ['a', 'b', 'c']

const arr3 = [
  { name: '张三', age: 16 },
  { name: '李四', age: 18 },
  { name: '王五', age: 20 }
]
arr3.forEach(function(item) {
  item.age += 10 // 引用值这种修改是可以改变原数组的
})
console.log(arr3)
/*
 * [
 *   { name: '张三', age: 26 },
 *   { name: '李四', age: 28 },
 *   { name: '王五', age: 30 }
 * ]
 * */
```

# map()方法

## 功能

将数组的所有成员依次传入回调函数，并将回调函数的返回值组成一个新的数组返回，记住要return。
如果回调函数没有return，则返回undefined

```js
const arr = [1, 2, 3]
const arr2 = arr.map(function(item) {
  item * item
})
console.log(arr2) // [undefined, undefined, undefined]
```

```js
const arr = [1, 2, 3]
const arr2 = arr.map(function(item) {
  return item * item
})
console.log(arr2) // [1, 4, 9]
```

## 返回值

在每次遍历中，通过回调函数处理后，返回的值组合而成的新的数组

## 参数

`参数1`：回调函数
`参数2`：用来绑定回调函数内部的this

```js
// 将arr2中的元素作为索引值，取出arr1中所对应的元素
const arr1 = ['a', 'b', 'c', 'd', 'e']
const arr2 = [1, 2]
const arr3 = arr2.map(function(item) {
  // return arr1[item]
  return this[item] // 使用this
}, arr1)
console.log(arr3) // ['b', 'c']
```

### 回调函数的参数

`item`：数组中的元素
`index`：数组元素的索引
`arr`：被遍历的数组

## 映射用法

```js
const arr1 = ['1', '2', '3']
const arr2 = arr1.map(parseInt) // parseInt(字符串, 进制) 将字符串转换为数字
/*
 * item作为字符串传入了parseInt，index作为进制传入了parseInt
 * 所以在当1被传进去时，会是parseInt(1, 0)，0进制会被作为十进制处理，因此返回1
 * 所以在当2被传进去时，会是parseInt(2, 1)，一进制里面没有2，因此返回NaN
 * */
console.log(arr2) // [1, NaN, NaN]
```

```js
const arr1 = ['1', '2', '3']
const arr2 = arr1.map(Number) // Number只接收一个参数，因此不存在进制转换问题
console.log(arr2) // [1, 2, 3]
```

## 注意

1. 该方法`不会`改变原数组，而是返回一个新数组
2. 会跳过空位，但不会跳过undefined和null

```js
function fn() {
  return 'abc'
}
console.log([1, undefined, 2].map(fn))
console.log([1, null, 2].map(fn))
console.log([1, , 2].map(fn))
```

[![pAVhRr8.png](https://s21.ax1x.com/2024/09/03/pAVhRr8.png)](https://imgse.com/i/pAVhRr8)

3. 不能通过break中止

# filter()方法

## 功能

用于过滤数组元素，`满足条件的`元素组成一个新数组返回，回调函数也需要return

## 返回值

满足条件的元素组成的新数组

## 参数

`参数1`：回调函数
`参数2`：用来绑定回调函数内部的this

```js
const obj = {
  num: 6
}
const arr1 = [10, 9, 2, 0, 16, 65]
const arr2 = arr1.filter(function(item) {
  return item > this.num
}, obj)
console.log(arr2) // [10, 9, 16, 65]
```

### 回调函数的参数

`item`：数组中的元素
`index`：数组元素的索引
`arr`：被遍历的数组

## 过滤用法

从数组中选出能整除2的元素

```js
const arr1 = [1, 2, 3, 4, 5, 6]
const arr2 = arr1.filter(function(item) {
  return item % 2 === 0
})
console.log(arr2) // [2, 4, 6]
```

如果回调函数中return一个false，则不会将这个元素添加到新数组中

```js
const arr1 = [1, 2, 3, 4, 5, 6]
const arr2 = arr1.filter(function(item) {
  // return null 或
  return 0
})
console.log(arr2) // []
```

该方法会将每一个元素都传入Boolean()，如果是true，则将这个元素添加到新数组中

```js
const arr1 = ['hello', 123, true, undefined, null, , false, [0], {}, new Boolean(false)]
const arr2 = arr1.filter(Boolean)
console.log(arr2)
```

[![pAZEbq0.png](https://s21.ax1x.com/2024/09/04/pAZEbq0.png)](https://imgse.com/i/pAZEbq0)

## 注意

1. 该方法`不会`改变原数组，而是返回一个新数组
2. 会跳过空位，但不会跳过undefined和null
3. 同样不能通过break中止

# some()方法

## 功能

用来判断数组中的某个元素是否符合回调函数中的条件，只要有一个元素符合条件，遍历中止，返回true，否则返回false

## 返回值

布尔值

## 参数

`参数1`：回调函数
`参数2`：用来绑定回调函数内部的this

```js
const arr = ['abc', true, 123, {}, , [], undefined, null]
const arr2 = [1, 2, 3, 4, 5, 6]
const res = arr.some(function(item) {
  console.log(item) // abc true 123
  return item > this[this.length - 1]
}, arr2)
console.log(res) // true
```

## 用法

判断数组当中是否有大于2的数

```js
const arr = [1, 2, 3, 4, 5, 6]
const res = arr.some(function(item) {
  // 类似于 || 运算符
  console.log(item) // 1 2 3
  return item > 2
})
console.log(res) // true
```

判断数组当中是否有大于6的数

```js
const arr = [1, 2, 3, 4, 5, 6]
const res = arr.some(function(item) {
  console.log(item) // 1 2 3 4 5 6
  return item > 6
})
console.log(res) // false
```

对于数组中不同类型元素的查找

```js
const arr = ['abc', true, 123, {}, , [], undefined, null]
const res = arr.some(function(item) {
  console.log(item)
  // return item === undefined // true
  // return typeof item === 'object' // true
  // return Array.isArray(item) // true
  // return item // true
  return !item // true
})
console.log(res)
```

## 注意

1. 该方法`不会`改变原数组
2. 会跳过空位，不会跳过undefined和null
3. 同样不能通过break中止

# every()方法

> 类似于 && 运算符

## 功能

可以用来判断数组中`所有元素`是都符合回调函数中的条件。所有元素符合条件，返回true，否则返回false。只要有一个不满足则遍历中止。

> 参数、返回值和使用方法类似some()方法

# some()和every()对于空数组的处理

some和every不会遍历空数组，some永远返回false，every永远返回true

```js
console.log([].some(function() { // 回调函数不会被执行 
  console.log('some')
  return true
})) // false
console.log([].every(function() { // 回调函数不会被执行 
  console.log('every')
  return false
})) // true
```

# reduce()和reduceRight()方法

## reduce()方法（从前往后）

### 功能

对数组中的每个元素按序执行一个提供的回调函数，每一次运行回调函数会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值.

### 返回值

累计之后的结果

### 参数

`参数1`：回调函数
`参数2`：初始值，默认为数组的第一个元素（可选）

```js
const arr1 = [1, 2, 3, 4, 5]
const res = arr1.reduce(function(acc, item, index) {
  console.log('acc:', acc, 'item:', item, 'index:', index)
  return acc + item
}, 10)
console.log('res:', res)
```

[![pAZ0ba6.png](https://s21.ax1x.com/2024/09/05/pAZ0ba6.png)](https://imgse.com/i/pAZ0ba6)

#### 无参数2时回调函数的参数

`accumulator（累加器）`：第一轮代表索引为0的元素，以后为上一轮的结果（必须）
`item`：第一轮为索引为1的元素，以后为下一个元素（必须）
`index`：`item`的索引位，默认值为1（可选）
`arr`：原数组（可选）

#### 有参数2时回调函数的参数

`accumulator（累加器）`：第一轮为参数2，以后为上一轮的结果（必须）
`item`：第一轮为索引为1的元素，以后为下一个元素（必须）
`index`：`item`的索引位，默认值为1（可选）
`arr`：原数组（可选）

```js
const arr1 = [1, 2, 3, 4, 5]
const res = arr1.reduce(function(acc, item, index, arr) {
  console.log(acc, item, index, arr)
})
```

[![pAZ0WPU.png](https://s21.ax1x.com/2024/09/05/pAZ0WPU.png)](https://imgse.com/i/pAZ0WPU)

### 归纳用法

数组内元素累加求和

```js
const arr1 = [1, 2, 3, 4, 5]
const res = arr1.reduce(function(acc, item, index, arr) {
  console.log(acc, item)
  return acc + item
})
console.log(res)
```

[![pAZ0fGF.png](https://s21.ax1x.com/2024/09/05/pAZ0fGF.png)](https://imgse.com/i/pAZ0fGF)

没有参数2：回调函数执行的次数 = 非空元素个数 - 1
有参数2：回调函数执行的次数 = 非空元素个数
> 一般情况下推荐设置初始值

```js
let n = 0
const arr1 = [1, 2, 3, 4, 5]
const res1 = arr1.reduce(function(acc, item, index) {
  console.log('acc:', acc, 'item:', item, 'index:', index)
  n++
  return acc + item
})
console.log('res:', res1)
console.log('n:', n)

let m = 0
const arr2 = [1, 2, 3, 4, 5]
const res2 = arr2.reduce(function(acc, item, index) {
  console.log('acc:', acc, 'item:', item, 'index:', index)
  m++
  return acc + item
}, 10)
console.log('res:', res2)
console.log('n:', m)
```

[![pAZBSsA.png](https://s21.ax1x.com/2024/09/05/pAZBSsA.png)](https://imgse.com/i/pAZBSsA)

找出数组中最长的字符串

```js
const arr = ['aaa', 'b', 'cccccc']
function getLongestStr(arr) {
  return arr.reduce(function(acc, item) {
    console.log('item:', item, 'acc:', acc)
    console.log()
    return item.length > acc.length ? item : acc
  }, '')
}
console.log('最长的字符串为:', getLongestStr(arr))
```

[![pAZBBFK.png](https://s21.ax1x.com/2024/09/05/pAZBBFK.png)](https://imgse.com/i/pAZBBFK)

### 注意

1. 该方法`不会`改变原数组
2. 会跳过空位，不会跳过undefined和null
3. 同样不能通过break中止

## reduceRight()方法（从后往前）

> 两个方法除了执行顺序不一样，其它都一样

```js
function substract(acc, item) {
  console.log('acc:', acc, 'item:', item)
  return acc - item
}
console.log('累加结果:', [3, 2, 1].reduce(substract))
console.log('累加结果:', [3, 2, 1].reduceRight(substract))
```

[![pAZB1iT.png](https://s21.ax1x.com/2024/09/05/pAZB1iT.png)](https://imgse.com/i/pAZB1iT)

# 链式调用

对于返回值是数组的方法，可以使用链式调用

## 示例

找出年龄大于18的用户，并将年龄打印出来

```js
const arr = [
  { name: 'a', age: 19 },
  { name: 'b', age: 16 },
  { name: 'c', age: 36 },
  { name: 'd', age: 26 },
  { name: 'e', age: 21 }
]
const arr2 = arr.map(function(item) {
  return item.age
}).filter(function(item) {
  return item > 18
}).forEach(function(item) {
  console.log(item) // 19 36 26 21
})
```

# 数组的扁平化处理

## 方法一：flat( )

`参数`：扁平化处理的深度（默认为1）

```js
const arr = ['a', 'b', ['c', ['d']], ['e', ['f', 'g', ['h']]]]
console.log(arr.flat())
console.log(arr.flat(2))
console.log(arr.flat(3))
console.log(arr.flat(Infinity)) // Infinity无穷大
```

[![pAZxdBQ.png](https://s21.ax1x.com/2024/09/06/pAZxdBQ.png)](https://imgse.com/i/pAZxdBQ)

## 方法二：递归

### 使用concat和递归

```js
const arr = ['a', 'b', ['c', ['d']], ['e', ['f', 'g', ['h']]]]

Array.prototype.myFlat = function() {
  let res = []
  this.forEach(function(item) {
    // 判断当前元素是否是数组
    if (Array.isArray(item)) {
      res = res.concat(item.myFlat()) // concat() 方法用于合并两个或多个数组
    } else {
      res.push(item)
    }
  })
  return res
}
console.log(arr.myFlat()) // ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
```

### 使用reduce、concat和递归

```js
const arr = ['a', 'b', ['c', ['d']], ['e', ['f', 'g', ['h']]]]

Array.prototype.myFlat = function() {
  return this.reduce(function(acc, item) {
    if (Array.isArray(item)) {
      return acc.concat(acc.myFlat())
    } else {
      return acc.concat(item)
    }
  }, [])
}
console.log(arr.myFlat()) // ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
```

# 数组去重

## 方法一：利用对象中键名的唯一性

```js
const arr = ['a', 'b', 'a', 'c', 'd', 'c', 'e', 'a', 'e', 'f', 'g', 'a']

const len = arr.length
const obj = {} // 用于保存去重后的对象
const res = [] // 用于保存去重后的数组
for (let i = 0; i < len; i++) {
  // 如果对象中不存在当前的键名，则在给对象中的元素赋值之前，该键名对应的键值都是undefined
  // 以此来判断该元素在对象中是否已经出现，即是否唯一，如果唯一，则将其添加到结果的数组中
  if (obj[arr[i]] === undefined) {
    res.push(arr[i])
  }
  obj[arr[i]] = arr[i] // 利用对象的键值的唯一性，将数组元素作为键值，可以自动去重
}
console.log(obj) // {a: 'a', b: 'b', c: 'c', d: 'd', e: 'e', f: 'f', g: 'g'}
console.log(res) // ['a', 'b', 'c', 'd', 'e', 'f', 'g']
```

## 方法二：利用indexOf判断某个元素是否在数组中

### indexOf()结合forEach()

```js
const arr = ['a', 'b', 'a', 'c', 'd', 'c', 'e', 'a', 'e', 'f', 'g', 'a']

const res = []
arr.forEach(function(item) {
  // res.indexOf(item) === -1 ? res.push(item) : '' 两种写法都可以
  res.indexOf(item) === -1 && res.push(item)
})
console.log(res)
```

### indexOf()结合filter()

```js
const arr = ['a', 'b', 'a', 'c', 'd', 'c', 'e', 'a', 'e', 'f', 'g', 'a']

const res = arr.filter(function(item) {
  if (this.indexOf(item) === -1) {
    this.push(item)
    return true
  }
}, [])
console.log(res)
```

### indexOf()结合reduce()

```js
const arr = ['a', 'b', 'a', 'c', 'd', 'c', 'e', 'a', 'e', 'f', 'g', 'a']

const res = arr.reduce(function(acc, item) {
  if (acc.indexOf(item) === -1) {
    acc.push(item)
  }
  return acc
}, [])
console.log(res)
```
