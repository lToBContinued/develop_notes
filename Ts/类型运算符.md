# TypeScript 类型运算符

TypeScript 提供强大的类型运算能力，可以使用各种类型运算符，对已有的类型进行计算，得到新类型。

## keyof 运算符

### 简介

keyof 是一个单目运算符，接受一个对象类型作为参数，返回该对象的所有键名组成的联合类型。

```typescript
type MyObj = {
  foo: number
  bat: string
}

type Keys = keyof MyObj // "foo" | "bat"
```

上面示例中，`keyof MyObj`返回`MyObj`的所有键名组成的联合类型，即`'foo'|'bar'`。

下面是另一个例子。

```typescript
interface T {
  0: boolean
  a: string
  b(): boolean
}

type KeyT = keyof T // 0 | "a" | "b"
```

-----

由于 JavaScript 对象的键名只有三种类型，所以对于任意对象的键名的联合类型就是`string|number|symbol`。

```typescript
type keyT = keyof any // string | number | symbol
```

-----

对于没有自定义键名的类型使用 keyof 运算符，返回`never`类型，表示不可能有这样类型的键名。

```typescript
type Key = keyof object // never
```

上面示例中，由于`object`类型没有自身的属性，也就没有键名，所以`keyof object`返回`never`类型。

-----

由于 keyof 返回的类型是`string|number|symbol`，如果有些场合只需要其中的一种类型，那么可以采用交叉类型的写法。

```typescript
type Capital<T extends string> = Capitalize<T>
type MyKeys<U extends object> = Capital<keyof U> 
// 错误：类型keyof U不满足约束string。
// 不能将类型string | number | symbol分配给类型string。
// 不能将类型number分配给类型string。
```

上面示例中，类型`Capital`只接受字符串作为类型参数，传入`keyof Obj`会报错，原因是这时的类型参数是`string|number|symbol`，跟字符串不兼容。采用下面的交叉类型写法，就不会报错。

```typescript
type Capital<T extends string> = Capitalize<T>
type MyKeys<U extends object> = Capital<keyof U & string>

let a: MyKeys<{ name: 'zs'; age: 18 }> // 'Name' | 'Age'
```

上面示例中，`string & keyof Obj`等同于`string & string|number|symbol`进行交集运算，最后返回`string`，因此`Capital<T extends string>`就不会报错了。

-----

如果对象属性名采用索引形式，keyof 会返回属性名的索引类型。

```typescript
interface T {
  [prop: number]: number
}

type KetT = keyof T // string
let a: KetT // let a: number

interface T2 {
  [prop: string]: number
}

type KeyT2 = keyof T2
let b: KeyT2 // let a: string | number
```

`keyof T2`返回的类型是`string|number`，原因是 JavaScript 属性名为字符串时，包含了属性名为数值的情况，因为数值属性名会自动转为字符串。

-----

如果 keyof 运算符用于数组或元组类型，得到的结果可能出人意料。

```typescript
type Result = keyof ['a', 'b', 'c']
// 返回 number | "0" | "1" | "2"
// | "length" | "pop" | "push" | ···
```

上面示例中，keyof 会返回数组的所有键名，包括数字键名和继承的键名。

-----

对于联合类型，keyof 返回成员共有的键名。

```typescript
type A = {
  a: string
  z: boolean
}

type B = {
  b: string
  z: boolean
}

type key1 = keyof (A | B) // "z"
```

-----

对于交叉类型，keyof 返回所有键名。

```typescript
type A = {
  a: string
  x: boolean
}

type B = {
  b: string
  y: number
}

type KeyT = keyof (A & B) // "a" | "x" | "b" | "y"

// 相当于 keyof (A & B) = keyof A | keyof B
```

-----

keyof 取出的是键名组成的联合类型，如果想取出键值组成的联合类型，可以像下面这样写。

```typescript
type MyObj = {
  foo: number
  bar: string
}

type Keys = keyof MyObj
type Values = MyObj[Keys] // number | string
```

上面示例中，`Keys`是键名组成的联合类型，而`MyObj[Keys]`会取出每个键名对应的键值类型，组成一个新的联合类型，即`number|string`。

### keyof 运算符的用途

keyof 运算符往往用于精确表达对象的属性类型。

举例来说，取出对象的某个指定属性的值，JavaScript 版本可以写成下面这样。

```javascript
function prop(obj, key) {
  return obj[key]
}
```

上面这个函数添加类型，只能写成下面这样。

```typescript
function prop(obj: object, key: string): any {
  return obj[key]
}
```

上面的类型声明有两个问题，一是无法表示参数`key`与参数`obj`之间的关系，二是返回值类型只能写成`any`。

有了 keyof 以后，就可以解决这两个问题，精确表达返回值类型。

```typescript
function prop<Obj, Key extends keyof Obj>(obj: Obj, key: Key): Obj[Key] {
  return obj[key]
}
```

上面示例中，`K extends keyof Obj`表示`K`是`Obj`的一个属性名，传入其他字符串会报错。返回值类型`Obj[K]`就表示`K`这个属性值的类型。

-----

keyof 的另一个用途是用于属性映射，即将一个类型的所有属性逐一映射成其他值。

```typescript
type NewProps<Obj> = {
  [Prop in keyof Obj]: boolean
}

type MyObj = {
  foo: number
  bar: string
  baz: boolean
}

type NewObj = NewProps<MyObj> // {foo: boolean, bar: boolean, baz: boolean}
```

上面示例中，类型`NewProps`是类型`Obj`的映射类型，前者继承了后者的所有属性，但是把所有属性值类型都改成了`boolean`。

-----

下面的例子是去掉 readonly 修饰符。

```typescript
type Mutable<Obj> = {
  -readonly [Prop in keyof Obj]: Obj[Prop]
}

// 用法
type MyObj = {
  readonly foo: number
  readonly bar: string
}
type NewObj = Mutable<MyObj> // {foo: number, bar: string}
```

上面示例中，`[Prop in keyof Obj]`是`Obj`类型的所有属性名，`-readonly`表示去除这些属性的只读特性。对应地，还有`+readonly`的写法，表示添加只读属性设置。

-----

下面的例子是让可选属性变成必有的属性。

```typescript
type Concrete<Obj> = {
  [Prop in keyof Obj]-?: Obj[Prop]
}

// 使用
type MyObj = {
  foo?: number
  bar?: string
}
type NewObj = Concrete<MyObj> // {foo: number, bar: string}
```

上面示例中，`[Prop in keyof Obj]`后面的`-?`表示去除可选属性设置。对应地，还有`+?`的写法，表示添加可选属性设置。

## in 运算符

JavaScript 语言中，`in`运算符用来确定对象是否包含某个属性名。

```typescript
const obj = {
  a: 123,
}

if ('a' in obj) {
  console.log('found a')
}
```

上面示例中，`in`运算符用来判断对象`obj`是否包含属性`a`。

`in`运算符的左侧是一个字符串，表示属性名，右侧是一个对象。它的返回值是一个布尔值。

-----

TypeScript 语言的类型运算中，`in`运算符有不同的用法，用来取出（遍历）联合类型的每一个成员类型。

```typescript
type U = 'a' | 'b' | 'c'

type Foo = {
  [Prop in U]: number
}

// 等同于
type Foo = {
  a: number
  b: number
  c: number
}
```

上面示例中，`[Prop in U]`表示依次取出联合类型`U`的每一个成员。

上一小节的例子也提到，`[Prop in keyof Obj]`表示取出对象`Obj`的每一个键名。

## 方括号运算符

方括号运算符（`[]`）用于取出对象的键值类型，比如`T[K]`会返回对象`T`的属性`K`的类型。

```typescript
type Person = {
  name: string
  age: number
  hobby: Array<string>
}
type name = Person['name'] // string
type hobby = Person['hobby'] // Array<string>
```

上面示例中，`Person['name']`返回属性`name`的类型，本例是`string`; `Person['hobby']` 返回属性`hobby`的类型，本例是`Array<string>`。

-----

方括号的参数如果是联合类型，那么返回的也是联合类型。

```typescript
type Person = {
  name: string
  age: number
  hobby: Array<string>
}
type name = Person['name' | 'age'] // string | number
type A = Person[keyof Person] // string | number | Array<string>
```

上面示例中，方括号里面是属性名的联合类型，所以返回的也是对应的属性值的联合类型。

如果访问不存在的属性，会报错。

```typescript
type Person = {
  name: string
  age: number
  hobby: Array<string>
}
type T = Person['address'] // 错误：类型Person上不存在属性address。
```

-----

方括号运算符的参数也可以是属性名的索引类型。

```typescript
type Obj = {
  [Prop: string]: number
}

type T = Obj[string] // number
```

上面示例中，`Obj`的属性名是字符串的索引类型，所以可以写成`Obj[string]`，代表所有字符串属性名，返回的就是它们的类型`number`。

这个语法对于数组也适用，可以使用`number`作为方括号的参数。

```typescript
type MyArray = {
  [Key: number]: string
}
const myArray: MyArray = ['a', 'b', 'c']

type Person = (typeof myArray)[number] // string
```

上面示例中，`MyArray`是一个数组，它的类型实际上是属性名的数值索引，而`typeof MyArray[number]`的`typeof`运算优先级高于方括号，所以返回的是所有数值键名的键值类型`string`。

-----

> 注意：方括号里面不能有值的运算。

```typescript
type Person = {
  age: number
  name: string
  alive: boolean
}

const key = 'age'
type Age = Person[key] // 错误：key表示值，但在此处用作类型。是否指“类型 key”?
```

上面两个示例，方括号里面都涉及值的运算，编译时不会进行这种运算，所以会报错。

## extends…?: 条件运算符

TypeScript 提供类似 JavaScript 的`?:`运算符这样的三元运算符，但多出了一个`extends`关键字。

条件运算符`extends...?:`可以根据当前类型是否符合某种条件，返回不同的类型。

```typescript
T extends U ? X : Y
```

上面式子中的`extends`用来判断，类型`T`是否可以赋值给类型`U`，即`T`是否为`U`的子类型，这里的`T`和`U`可以是任意类型。如果`T`能够赋值给类型`U`，表达式的结果为类型`X`，否则结果为类型`Y`。

```typescript
type T = 1 extends number ? true : false // true
```

上面示例中，`1`是`number`的子类型，所以返回`true`。

-----

下面是另外一个例子。

```typescript
interface Animal {
  live(): void
}

interface Dog extends Animal {
  woof(): void
}

type T = Dog extends Animal ? number : string // number
type T2 = RegExp extends Animal ? number : string // string
```

上面示例中，`Dog`是`Animal`的子类型，所以`T1`的类型是`number`。`RegExp`不是`Animal`的子类型，所以`T2`的类型是`string`。

一般来说，调换`extends`两侧类型，会返回相反的结果。举例来说，有两个类`Dog`和`Animal`，前者是后者的子类型，那么`Cat extends Animal`就为真，而`Animal extends Cat`就为伪。

-----

如果需要判断的类型是一个联合类型，那么条件运算符会展开这个联合类型。

```typescript
(A|B) extends U ? X : Y
// 等同于
(A extends U ? X : Y) | (B extends U ? X : Y)
```

上面示例中，`A|B`是一个联合类型，进行条件运算时，相当于`A`和`B`分别进行运算符，返回结果组成一个联合类型。

-----

如果不希望联合类型被条件运算符展开，可以把`extends`两侧的操作数都放在方括号里面。

```typescript
type ToArray<Type> = Type extends any ? Type[] : never
type T = ToArray<string | number> // string[] | number[]
```

上面的示例一，传入`ToArray<Type>`的类型参数是一个联合类型，所以会被展开，返回的也是联合类型。

```typescript
type ToArray<Type> = [Type] extends [any] ? Type[] : never
type T = ToArray<string | number> // (string | number)[]
```

示例二是`extends`两侧的运算数都放在方括号里面，所以传入的联合类型不会展开，返回的是一个数组。

-----

条件运算符还可以嵌套使用。

```typescript
type LiteralTypeName<T> = T extends undefined
  ? 'undefined'
  : T extends null
    ? 'null'
    : T extends boolean
      ? 'boolean'
      : T extends number
        ? 'number'
        : T extends bigint
          ? 'bigint'
          : T extends string
            ? 'string'
            : never

type A = LiteralTypeName<6> // "number"
type B = LiteralTypeName<null> // "null"
type C = LiteralTypeName<'张三' | 18 | true> // "string" | "number" | "boolean"
```

上面示例是一个多重判断，返回一个字符串的值类型，对应当前类型。

## infer 关键字

`infer`关键字用来定义泛型里面推断出来的类型参数，而不是外部传入的类型参数。

它通常跟条件运算符一起使用，用在`extends`关键字后面的父类型之中。

```typescript
type Flatten<Type> = Type extends Array<infer Item> ? Item : Type

type Arr = Flatten<string[]> // string
type Arr2 = Flatten<Array<number>> // number
type Arr3 = Flatten<boolean> // boolean
```

上面示例中，`Type`是外部传入的类型参数，如果它是数组`Array<T>`的子类型，那么就将类型变量`Item`推断为`T`，即`Item`代表数组的成员类型，写成`infer Item`，表示`Item`这个类型参数是从当前信息中推断出来的。

上面示例中，第一个例子`Flatten<string[]>`传入的类型参数是`string[]`，可以推断出`Item`的类型是`string`，所以返回的是`string`。第三个例子`Flatten<boolean>`传入的类型参数是`boolean`，它不是数组的子类型，所以直接返回自身。

一旦定义了`Item`，后面的代码就可以使用这个类型参数了。

-----

下面的例子使用`infer`，推断函数的参数类型和返回值类型。

```typescript
type ReturnPromise<T> = T extends (...args: infer A) => infer B ? (...args: A) => Promise<B> : T
```

上面示例中，如果`T`是函数，就返回这个函数的 Promise 版本，否则原样返回。`infer A`表示该函数的参数类型为`A`，`infer R`表示该函数的返回值类型为`R`。

如果不使用`infer`，就不得不把`ReturnPromise<T>`写成`ReturnPromise<T, A, R>`，这样就很麻烦，相当于开发者必须人肉推断编译器可以完成的工作。

-----

下面是`infer`提取对象指定属性的例子。

```typescript
type MyType<T> = T extends {
  a: infer N
  b: infer M
}
  ? [M, N]
  : never

type T = MyType<{ a: string; b: number }> // [number, string]
```

上面示例中，`infer`提取了参数对象的属性`a`和属性`b`的类型。

-----

下面是`infer`通过正则匹配提取类型参数的例子。

```typescript
type Str = 'foo-bar'

type Bar = Str extends `foo-${infer rest}` ? rest : never // 'bar'
```

上面示例中，`rest`是从模板字符串提取的类型参数。