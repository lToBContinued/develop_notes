# 函数

## 简介

```typescript
/*函数类型的声明*/

// 1.
// 函数fun1()在声明时，需要给出参数txt的类型（string），以及返回值的类型（void），后者写在参数列表的圆括号后面。
function fun1(txt: string): void {
  console.log('你好' + txt)
}

// 2.
// 返回值的类型通常可以不写，因为 TypeScript 自己会推断出来。
function fun2(txt: string) {
  console.log('你好' + txt)
}

// 3.
// 如果变量被赋值为一个函数，变量的类型有两种写法。
// 通过等号右边的函数类型，推断出变量fun3的类型
const fun3 = function (txt: string) {
  console.log('你好' + txt)
}
// 使用箭头函数的形式，为变量fun4指定类型，参数的类型写在箭头左侧，返回值的类型写在箭头右侧
const fun4: (txt: string) => void = function (txt) {
  console.log('你好' + txt)
}

// 4.
// 函数类型里面的参数名与实际参数名，可以不一致。
const fun5: (x: string) => void = function (txt) {
  console.log('你好' + txt)
}

// 5.
// 如果函数的类型定义很冗长，或者多个函数使用同一种类型，往往用type命令为函数类型定义一个别名，便于指定给其他变量。
type MyFunc1 = (x: string) => void
const fun6: MyFunc1 = function (txt) {
  console.log('你好' + txt)
}
const fun7: MyFunc1 = function (address) {
  console.log('地址：' + address)
}

// 6.
// 函数的实际参数个数，可以少于类型指定的参数个数，但是不能多于，即 TypeScript 允许省略参数。
let fun8: (a: number, b: number) => number
fun8 = (a) => a // 正确
fun8 = (a, b) => a + b // 正确
// fun8 = (a, b, c) => a + b + c // 报错

// 7.
// 如果一个变量要套用另一个函数类型，有一个小技巧，就是使用typeof运算符。
function fun9(x: number, y: number): number {
  return x + y
}

const fun10: typeof fun9 = function (a, b) {
  return a + b
}

// 8.
// 函数类型还可以采用对象的写法。
let fun11: {
  (x: number, y: number): number
}

fun11 = function (a, b) {
  return a + b
}

// 函数类型的对象写法如下。
/**
 * {
 *   (参数列表): 返回值
 * }
 */
// 注意，这种写法的函数参数与返回值之间，间隔符是冒号:，而不是正常写法的箭头=>，因为这里采用的是对象类型的写法，对象的属性名与属性值之间使用的是冒号。

// 这种写法平时很少用，但是非常合适用在一个场合：函数本身存在属性。
function fun12(x: number) {
  return x
}

fun12.version = 'v1.0'

let fun13: {
  (x: number, y: number): number
  version: string
} = fun12

console.log(fun13.version)

// 9.
// 函数类型也可以使用 Interface 来声明，这种写法就是对象写法的翻版
interface Fun14 {
  (x: number, y: number): number
}

const fun14: Fun14 = function (a, b) {
  return a + b
}
```
## Function 类型

TypeScript 提供 Function 类型表示函数，任何函数都属于这个类型。

```typescript
function doSomething(callback: Function) {
  return callback(1, 2, 3)
}
```

上面示例中，参数`f`的类型就是`Function`，代表这是一个函数。

Function 类型的值都可以直接执行。

Function 类型的函数可以接受任意数量的参数，每个参数的类型都是`any`，返回值的类型也是`any`，代表没有任何约束，所以不建议使用这个类型，给出函数详细的类型声明会更好。

## 箭头函数

箭头函数是普通函数的一种简化写法，它的类型写法与普通函数类似。

```typescript
const repeat = (str: string, times: number): string => {
  return str.repeat(times)
}
```

上面示例中，变量repeat被赋值为一个箭头函数，类型声明写在箭头函数的定义里面。其中，参数的类型写在参数名后面，返回值类型写在参数列表的圆括号后面。

> 注意：类型写在箭头函数的定义里面，与使用箭头函数表示函数类型，写法有所不同。

------

```typescript
const greet = (fn: (a: string) => string): void => {
  console.log(fn('你好呀！'))
}
const foo = (str: string): string => {
  return str + 'hello'
}
greet(foo) // 你好呀！hello
```

上面示例中，函数`greet()`的参数`fn`是一个函数，类型就用箭头函数表示。这时，`fn`的返回值类型要写在箭头右侧，而不是写在参数列表的圆括号后面。

------

例：

```typescript
type Person = {
  name: string
}

const people = ['alice', 'bob', 'jan'].map((item): Person => {
  return { name: item }
})
console.log(people) // [ { name: 'alice' }, { name: 'bob' }, { name: 'jan' } ]
```

上面示例中，`Person`是一个类型别名，代表一个对象，该对象有属性`name`。变量`people`是数组的`map()`方法的返回值。

`map()`方法的参数是一个箭头函数`(name):Person => ({name})`，该箭头函数的参数`name`的类型省略了，因为可以从`map()`的类型定义推断出来，箭头函数的返回值类型为`Person`。相应地，变量`people`的类型是`Person[]`。

## 可选参数

如果函数的某个参数可以省略，则在参数名后面加问号表示。

```typescript
function fun(x?: number, y?: number): void {}

fun() // 正确
fun(1) // 正确
fun(1, 2) // 正确
```

参数名带有问号，表示该参数的类型实际上是`原始类型|undefined`，它有可能为`undefined`。比如，上例的`x`和`y`虽然类型都声明为`number`，但是实际上是`number|undefined`。

------

```typescript
function fun(x?: number): void {}

fun(undefined) // 正确
```

上面示例中，参数`x`是可选的，等同于说`x`可以赋值为`undefined`。

------

但是，反过来就不成立，类型显式设为`undefined`的参数，就不能省略。

```typescript
function fun(x: number | undefined): void {}

fun() // 错误
```

上面示例中，参数`x`的类型是`number|undefined`，表示要么传入一个数值，要么传入`undefined`，如果省略这个参数，就会报错。

-----

函数的可选参数只能在参数列表的尾部，跟在必选参数的后面。

```typescript
const myFun = (a?: number, b: string): void => {} // 报错：必选参数不能位于可选参数后。
```

上面示例中，可选参数在必选参数前面，就报错了。

-----

如果前部参数有可能为空，这时只能显式注明该参数类型可能为`undefined`。

```typescript
const myFun = (a: number | undefined, b: string): void => {} // 正确

myFun('你好') // 错误：应有 2 个参数，但获得 1 个。
myFun(undefined, '你好') // 正确
```

上面示例中，参数`a`有可能为空，就只能显式注明类型包括`undefined`，传参时也要显式传入`undefined`。

-----

函数体内部用到可选参数时，需要判断该参数是否为`undefined`，以免不必要的错误。

```typescript
type Add = {
  (x: number, y?: number): number
}

const add: Add = (x, y) => {
  if (y === undefined) {
    return x
  }
  return x + y
}
```

上面示例中，由于函数的第二个参数为可选参数，所以函数体内部需要判断一下，该参数是否为空。

## 参数默认值

TypeScript 函数的参数默认值写法，与 JavaScript 一致。

设置了默认值的参数，就是可选的。如果不传入该参数，它就会等于默认值。

```typescript
const createPoint = (x: number = 0, y: number = 0): [number, number] => {
  return [x, y]
}

console.log(createPoint()) // [0, 0]
```

上面示例中，参数`x`和`y`的默认值都是`0`，调用`createPoint()`时，这两个参数都是可以省略的。这里其实可以省略`x`和`y`的类型声明，因为可以从默认值推断出来。

```typescript
const createPoint = (x = 0, y = 0): [number, number] => {
  return [x, y]
}

console.log(createPoint()) // [0, 0]
```

-----

可选参数与默认值不能同时使用。

```typescript
function fn(x?: number = 0): void {} // 报错：参数不能包含问号和初始化表达式。
```

上面示例中，`x`是可选参数，还设置了默认值，结果就报错了。

-----

设有默认值的参数，如果传入`undefined`，也会触发默认值。

```typescript
function fn(x = 456): number {
  return x
}

console.log(fn(undefined)) // 456
```

-----

具有默认值的参数如果不位于参数列表的末尾，调用时不能省略，如果要触发默认值，必须显式传入`undefined`。

```typescript
const add = (x: number = 0, y: number): number => {
  return x + y
}

add(1) // 报错：应有 2 个参数，但获得 1 个。
console.log(add(undefined, 1)) // 1
```

> 注意：由于默认值是在函数实现时设置的，因此无法使用对象或者接口的形式来定义函数参数的默认值。只能通过将参数标记为可选参数来达到类似的效果。

## 参数结构

函数参数如果存在变量解构，类型写法如下。

```typescript
function fn([x, y]: [number, number]): void {}

function sum({ a, b, c }: { a: number; b: number; c: number }): void {
  console.log(a + b + c)
}
```

参数结构可以结合类型别名（type 命令）一起使用，代码会看起来简洁一些。

```typescript
type ABC = {
  a: number
  b: number
  c: number
}

interface Sum {
  ({ a, b, c }: ABC): number
}

const sum: Sum = ({ a, b, c }) => {
  return a + b + c
}
```

## 剩余参数

剩余参数可以是数组（剩余参数类型相同），也可能是元组（剩余参数类型不同）。

```typescript
// 剩余参数为数组
function joinNumbers(...nums: number[]): void {}
// 剩余参数为元祖
function fn(...args: [string, number, boolean]): void {}
```

> 注意：元组需要声明每一个剩余参数的类型。如果元组里面的参数是可选的，则要使用可选参数。

```typescript
function fn(...args: [boolean, string?]) {}
```

-----

例：

```typescript
function multiply(n: number, ...m: number[]): number[] {
  return m.map((item) => n * item)
}

console.log(multiply(2, 1, 2, 3, 4, 5)) // [ 2, 4, 6, 8, 10 ]
```

上面示例中，参数`m`就是剩余参数，它的类型是一个数组。

-----

剩余参数甚至可以嵌套。

```typescript
function multiply(...args: [string, ...number[]]): Array<string | number> {
  return args
}

console.log(multiply('hello', 1, 2, 3, 4, 5)) // [ 'hello', 1, 2, 3, 4, 5 ]
```

-----

剩余参数可以与变量解构结合使用。

```typescript
function repeat(...[str, times]: [string, number]): string {
  return str.repeat(times)
}

// 等同于
function repeat(str: string, times: number): string {
  return str.repeat(times)
}
```

## readonly 只读参数

如果函数内部不能修改某个参数，可以在函数定义时，在参数类型前面加上`readonly`关键字，表示这是只读参数。

```typescript
function arraySum(arr: readonly number[]) {
  arr[0] = 0 // 报错：类型readonly number[]中的索引签名仅允许读取。
}
```

上面示例中，参数`arr`的类型是`readonly number[]`，表示为只读参数。如果函数体内部修改这个数组，就会报错。

## void 类型

void 类型表示函数没有返回值。

```typescript
function fn(): void {
  console.log('hello')
}
```

上面示例中，函数`f`没有返回值，类型就要写成`void`。如果有返回值就会报错

-----

void 类型允许返回`undefined`或`null`。

```typescript
function fn1(): void {
  return null
}

function fn2(): void {
  return undefined
}
```

如果打开了`strictNullChecks`编译选项，那么 void 类型只允许返回`undefined`。如果返回`null`，就会报错。这是因为 JavaScript 规定，如果函数没有返回值，就等同于返回`undefined`。

```typescript
function fn1(): void {
  return null // 报错：不能将类型null分配给类型void。
}
```

-----

需要特别注意的是，如果变量、对象方法、函数参数的类型是 void 类型的函数，那么并不代表不能赋值为有返回值的函数。恰恰相反，该变量、对象方法和函数参数可以接受返回任意值的函数，这时并不会报错。

```typescript
type VoidFunc = () => void

const fn: VoidFunc = () => {
  return 123
}
```

上面示例中，变量`f`的类型是`voidFunc`，是一个没有返回值的函数类型。但是实际上，`f`的值是一个有返回值的函数（返回`123`），编译时不会报错。

这是因为，这时 TypeScript 认为，这里的 void 类型只是表示该函数的返回值没有利用价值，或者说不应该使用该函数的返回值。只要不用到这里的返回值，就不会报错。

如果后面使用了这个函数的返回值，就违反了约定，则会报错。

```typescript
type VoidFunc = () => void

const fn: VoidFunc = () => {
  return 123
}

console.log(fn()) // 警告：使用了 void 函数返回值
```

这样设计是有现实意义的。举例来说，数组方法`Array.prototype.forEach(fn)`的参数`fn`是一个函数，而且这个函数应该没有返回值，即返回值类型是`void`。

```typescript
const src = [1, 2, 3]
const res = []
src.forEach((item) => {
  return res.push(item)
})
```

上面示例中，`push()`有返回值，表示新插入的元素在数组里面的位置。但是，对于`forEach()`方法来说，这个返回值是没有作用的，根本用不到，所以 TypeScript 不会报错。

-----

> 注意：这种情况仅限于**变量**、**对象方法**和**函数参数**，函数字面量如果声明了返回值是 void 类型，还是不能有返回值。

```typescript
function f1(): void {
  return 123 // 错误：不能将类型number分配给类型void。
}

const fn2 = function (): void {
  return true // 错误：不能将类型boolean分配给类型void。
}
```

上面示例中，函数字面量声明了返回`void`类型，这时只要有返回值（除了`undefined`和`null`）就会报错。

-----

除了函数，其他变量声明为`void`类型没有多大意义，因为这时只能赋值为`undefined`或者`null`（假定没有打开`strictNullChecks`) 。

```typescript
let a: void

a = undefined
// 没有打开 strictNullChecks 的情况下
a = null
```

## never 类型

`never`类型表示肯定不会出现的值。它用在函数的返回值，就表示某个函数肯定不会返回值，即函数不会正常执行结束。

它主要有以下两种情况。

1. 抛出错误的函数

```typescript
function fail(): never {
  throw new Error('失败')
}
fail() // Error: 失败
```

上面示例中，函数`fail()`会抛错，不会正常退出，所以返回值类型是`never`。

> 注意：只有抛出错误，才是 never 类型。如果显式用`return`语句返回一个 Error 对象，返回值就不是 never 类型。

```typescript
function fail(): never {
  return new Error('失败') // 错误：不能将类型Error分配给类型never。
}

function fail2(): Error {
  return new Error('失败') // 正确
}
```

上面示例中，函数`fail()`返回一个 Error 对象，所以返回值类型是 Error。

-----

2. 无限执行的函数。

```typescript
const sing = (): never => {
  while (true) {
    console.log('sing')
  }
}
```

上面示例中，函数`sing()`会永远执行，不会返回，所以返回值类型是`never`。

> 注意：`never`类型不同于`void`类型。前者表示函数没有执行结束，不可能有返回值；后者表示函数正常执行结束，但是不返回值，或者说返回`undefined`。

```typescript
const sing1 = (): void => {
  console.log('sing')
}

const sing2 = (): never => { // 错误：返回“从不”的函数不能具有可访问的终结点。
  console.log('sing')
}
```

上面示例中，函数`sing()`虽然没有`return`语句，但实际上是省略了`return undefined`这行语句，真实的返回值是`undefined`。所以，它的返回值类型要写成`void`，而不是`never`，写成`never`会报错。

-----

如果一个函数抛出了异常或者陷入了死循环，那么该函数无法正常返回一个值，因此该函数的返回值类型就是`never`。如果程序中调用了一个返回值类型为`never`的函数，那么就意味着程序会在该函数的调用位置终止，永远不会继续执行后续的代码。

```typescript
const neverReturn = (str: string): never => {
  throw new Error(`${str}不能为undefined`)
}
const fn = (x: string | undefined) => {
  if (x === undefined) {
    return neverReturn('x')
  }
  return x // 推断为 string
}

console.log(fn('你好')) // 你好
fn(undefined) // Error: x不能为undefined
```

上面示例中，函数`fn()`的参数`x`的类型为`string|undefined`。但是，`x`类型为`undefined`时，调用了`neverReturns()`。这个函数不会返回，因此 TypeScript 可以推断出，判断语句后面的那个`x`，类型一定是`string`。