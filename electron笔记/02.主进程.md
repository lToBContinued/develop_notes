# 进程

electron 中有两个进程：**主进程**和**渲染进程**

1. **主进程**：启动项目时运行的 main.js 文件就是我们说的主进程。在主进程运行的脚本可以以创建 web 页面的形式展示 GUI。**主进程只有一个**。
2. **渲染进程**：每个 electron 的页面都在运行着自己的进程，这样的进程称之为渲染进程（基于 chromium 的多进程结构）

[![pEnBznI.png](https://s21.ax1x.com/2025/02/10/pEnBznI.png)](https://imgse.com/i/pEnBznI)

主进程使用 BrowserWindow 创建实例，主进程销毁后，对应的渲染进程会被终止。主进程与渲染进程通过 IPC 方式（事件驱动）进行通信。

## 主进程

### 主进程生命周期

#### 所有窗口被关闭 window-all-closed

window-all-closed

在 Windows 和 Linux 上，我们通常希望在关闭一个应用的所有窗口后让它退出。

```js
app.on('window-all-closed', () => {
  // 当所有窗口都被关闭时，执行以下代码
  if (process.platform !== 'darwin') {
    // 如果当前平台不是 macOS（darwin），则退出应用程序
    app.quit()
  }
})
```

#### 窗口的打开 activate

activate

与前二者相比，即使没有打开任何窗口，macOS 应用通常也会继续运行。在没有窗口可用时调用 app 会打开一个新窗口。

因为窗口无法在 ready 事件前创建，你应当在你的应用初始化后仅监听 activate 事件。 要实现这个，仅监听 whenReady() 回调即可。

```js
app.whenReady().then(() => {
  createWindow()

  app.on('activate', ()=>{
    // 当应用程序被激活时，执行以下代码
    if (BrowserWindow.getAllWindows().length === 0) {
      // 如果当前没有打开的窗口，则创建一个新窗口
      createWindow()
    }
  })
})
```

#### 窗口关闭事件

1. **before-quit**：在程序关闭窗口前被触发
2. **will-quit**：当所有窗口被关闭后被触发，同时应用程序将退出。
3. **quit**：在应用程序退出时被触发

main.js

```js
app.on('before-quit', () => {
  console.log('===> before-quit')
})

app.on('will-quit', () => {
  console.log('===> will-quit')
})

app.on('quit', () => {
  console.log('===> quit')
})
```

[![pEKR6Nd.png](https://s21.ax1x.com/2025/02/16/pEKR6Nd.png)](https://imgse.com/i/pEKR6Nd)

#### 焦点事件

1. **focus**：当窗口获得焦点时触发
2. **blur**：当窗口失去焦点时触发

```js
app.on('browser-window-focus', () => {
  console.log('===> browser-window-focus')
})

app.on('browser-window-blur', () => {
  console.log('===> browser-window-blur')
})
```

例如：当切屏到另一个应用或最小化应用时，会触发 blur 事件，再回到应用时触发 focus 事件。

### 主进程事件

#### quit

尝试关闭所有窗口 将首先发出 before-quit 事件。 如果所有窗口都已成功关闭, 则将发出 will-quit 事件, 并且默认情况下应用程序将终止。

```js
app.on('browser-window-blur', () => {
  console.log('===> browser-window-blur')
  // 应用失去焦点，3秒后退出
  setTimeout(() => {
    app.quit()
  }, 3000)
})

app.on('before-quit', () => {
  console.log('===> before-quit')
})

app.on('will-quit', () => {
  console.log('===> will-quit')
})

app.on('quit', () => {
  console.log('===> quit')
})
```

> 此方法会确保执行所有 beforeunload 和 unload 事件处理程序。 可以在退出窗口之前的 beforeunload 事件处理程序中返回 false 取消退出。

#### exit

所有窗口都将立即被关闭，而不询问用户，而且 before-quit 和 will-quit 事件也不会被触发。

```js
app.on('browser-window-blur', () => {
  console.log('===> browser-window-blur')
  setTimeout(() => {
    app.exit()
  }, 3000)
})
```

#### getPath

获取系统中的一些目录，返回 string - 与 name 关联的目录或文件的路径。 失败会抛出一个Error。

main.js

```js
console.log(app.getPath('desktop')) // D:\file\desktop
console.log(app.getPath('music')) // C:\Users\ToBContinued\Music
console.log(app.getPath('temp')) // C:\Users\TOBCON~1\AppData\Local\Temp
console.log(app.getPath('userData')) // C:\Users\ToBContinued\AppData\Roaming\electron-basics
```

## 预加载脚本

### 基本使用

Electron 的预加载脚本是在渲染进程中运行的一段 js 代码，用于在主进程和渲染进程之间建立安全的桥梁。

**作用**：

1. 暴露有限的 Node.js API：预加载脚本可以在渲染进程中安全地暴露部分 Node.js API 或自定义方法，避免直接访问全部 Node.js API 带来的安全隐患。
2. 进程间通信：通过预加载脚本，渲染进程可以与主进程进行通信，实现数据交换和功能调用。
3. 增强安全性：通过限制渲染进程的权限，预加载脚本能有效防止恶意代码的执行。

### 预加载脚本运行在渲染进程中

main.js

```js
const {app, BrowserWindow} = require('electron')
const path = require('path')

const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    webPreferences: {
      // 预加载脚本的引入路径必须是绝对路径
      preload: path.resolve(__dirname, './preload.js')
    }
  })
  win.webContents.openDevTools()
  win.loadFile('index.html')
}

app.whenReady().then(() => {
  createWindow()
})
```

preload.js

```js
console.log('预加载脚本') // 这行代码会在渲染进程中打印
```

[![pEKwTrn.png](https://s21.ax1x.com/2025/02/15/pEKwTrn.png)](https://imgse.com/i/pEKwTrn)

### contextBridge

contextBridge 是 Electron 提供的一个 API，用于安全地在主进程和渲染进程之间传递数据和功能。它的主要作用是解决 Electron 应用中的安全性问题，尤其是在启用 contextIsolation（上下文隔离）时。

使用 contextBridge 定义一个全局变量

preload.js

```js
const { contextBridge } = require('electron')

// 使用 contextBridge 暴露一个全局变量
contextBridge.exposeInMainWorld('myApi', {
  platform: process.platform
})
```

全局变量被保存在 window 对象中

```js
console.log(window.myApi)
console.log(window.myApi.platform)
```

[![pEK0SM9.png](https://s21.ax1x.com/2025/02/15/pEK0SM9.png)](https://imgse.com/i/pEK0SM9)

## 主进程与渲染进程通信

**ipcRenderer**：从渲染器进程到主进程的异步通信，可以从渲染进程向主进程发送信息，也可以接受从主进程传来的信息

**ipcMain**：从主进程到渲染进程的异步通信，可以从主进程向渲染进程发送信息，也可以接受从渲染进程传来的信息

### 渲染进程 -> 主进程

**ipcRenderer.invoke(channel, ...args)**：通过 channel 向主进程发送消息，并异步等待结果。

1. channel：发送消息的事件名称
2. ...args：发送的消息内容

preload.js

```js
// ipcRenderer 用于渲染进程向主进程发送消息和接收主进程返回的消息
const { contextBridge, ipcRenderer } = require('electron')

// 1. 在预加载脚本中定义一个发送消息的方法
const handleSend = async () => {
  // 4. handleSend 被调用，ipcRenderer.invoke 会向主进程发送消息，消息名字为 send-event，消息内容为 hahahaha，并异步等待主进程返回的消息
  // 6. 接收主进程返回的消息
  let fallback = await ipcRenderer.invoke('send-event', 'hahahaha')
  console.log(fallback)
}

contextBridge.exposeInMainWorld('myApi', {
  platform: process.platform,
  handleSend // 2. 暴露 handleSend 方法
})
```

app.js

```js
document.querySelector('#btn').addEventListener('click', () => {
  // 3. 调用 preload 暴露的方法，当点击按钮时，会调用 handleSend 方法
  // 使用 window 对象的时候，window 可以省略
  myApi.handleSend()
})
```

**ipcMain.handle(channel, listener)**：为一个 invokeable 的 IPC 添加一个handler。 每当一个渲染进程调用 ipcRenderer.invoke(channel, ...args) 时这个处理器就会被调用。

1. channel：监听的 invokeable 的事件名称
2. listener：监听的事件回调函数，接收两个参数：event 和 args，event 是事件对象，args 是从渲染进程发送过来的消息内容

main.js

```js
// ipcMain 用于主进程接收渲染进程发送的消息和返回的消息
const { app, BrowserWindow, ipcMain } = require('electron')
const path = require('path')

const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    webPreferences: {
      preload: path.resolve(__dirname, './preload.js')
    }
  })
  win.webContents.openDevTools()
  win.loadFile('index.html')
}

app.whenReady().then(() => {
  createWindow()
})

// 5. 主进程中使用 ipcMain.handle 监听渲染进程中名为 send-event 的消息，并执行一个回调函数，并返回给渲染进程一个消息
ipcMain.handle('send-event', (event, arg) => {
  console.log(arg)
  return arg
})
```

[![pEKR874.png](https://s21.ax1x.com/2025/02/16/pEKR874.png)](https://imgse.com/i/pEKR874)

## 窗口操作

### BrowserWindow

BrowserWindow 类暴露了各种方法来修改应用窗口的外观和行为。

#### 创建实例

main.js

```js
const { BrowserWindow } = require('electron')

const createWindow = () => {
  const win = new BrowserWindow() // 创建一个窗口实例
}
```

窗口可以实例化多个

```js
const { app, BrowserWindow, ipcMain } = require('electron')

const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    backgroundColor: 'pink',
  })
  win.loadFile('index.html')
  
  const win2 = new BrowserWindow({
    width: 600,
    height: 400
  })
  win2.loadURL('https://www.bilibili.com')
}
```

[![pEKfrYd.png](https://s21.ax1x.com/2025/02/16/pEKfrYd.png)](https://imgse.com/i/pEKfrYd)

#### 优雅的显示窗口

##### 使用 ready-to-show 事件

当我们使用 win.loadUrl 或者 win.loadFile 加载一个页面时，在页面加载完成之前就会打开窗口，会产生一段时间的白屏，为了优化体验，我们可以使用 ready-to-show 事件来优雅的显示窗口。

**ready-to-show**事件：当页面已经渲染完成(但是还没有显示) 并且窗口可以被显示时触发

main.js

```js
const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    show: false, // 1. 先不显示窗口
  })

  win.loadURL('https://www.github.com')
  // 2. 等窗口中的内容加载完成后再显示窗口
  win.on('ready-to-show', () => {
    win.show()
  })
}
```

##### 设置 backgroundColor 属性

main.js

```js
const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    backgroundColor: '#6435c9',
  })

  // win.loadURL('https://www.bilibili.com')
  win.loadFile('index.html')
}
```

[![pEKfwwD.png](https://s21.ax1x.com/2025/02/16/pEKfwwD.png)](https://imgse.com/i/pEKfwwD)

#### 父子窗口

main.js

```js
const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    backgroundColor: 'pink',
  })
  win.loadFile('index.html')
  
  const win2 = new BrowserWindow({
    width: 600,
    height: 400,
    parent: win, // 建立父子关系
  })
  win2.loadURL('https://www.bilibili.com')
}
```

> 建立父子关系的窗口在关闭父窗口时会自动关闭子窗口。

#### 模态窗口

```js
const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    backgroundColor: 'pink',
  })
  win.loadFile('index.html')
  
  const win2 = new BrowserWindow({
    width: 600,
    height: 400,
    parent: win,
    modal: true, // 模态窗口
  })
  win2.loadURL('https://www.bilibili.com')
}
```

> 在关闭模态窗口前，不能操作父窗口。

#### 原生的窗口框架

frame 是 BrowserWindow 的一个选项，用于控制浏览器窗口是否显示原生的窗口框架（包括标题栏、边框和窗口控制按钮，如最小化、最大化和关闭按钮）

```js
const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    frame: false, // 不显示窗口的默认边框
    backgroundColor: 'pink',
  })
  win.loadFile('index.html')
}
```

[![pEKfclt.png](https://s21.ax1x.com/2025/02/16/pEKfclt.png)](https://imgse.com/i/pEKfclt)

注意：设置 frame 为 false 后窗口无法拖动，此时可以通过 css 来解决

app.css

```css
html {
    height: 100%; /* 让html高度为100% */
}

body {
    margin: 0;
    padding: 0;
    height: 100%; /* 让body高度为100% */
    border: 1px solid red;
    -webkit-app-region: drag; /* 允许拖动 */
}

/* 其它的元素要设置禁止拖动，不然会产生一些和窗口可以拖动的冲突的bug */
button,
input {
    -webkit-app-region: no-drag; /* 禁止拖动 */
}
```

在 index.html 中引入

```html
<link rel="stylesheet" href="./app.css">
```

#### 静态方法

##### getAllWindows()

**BrowserWindow.getAllWindows()**：所有打开的窗口的数组

##### getFocusedWindow()

**BrowserWindow.getFocusedWindow()**：返回此应用程序中当前获得焦点的窗口，如果无就返回 null

#### 保存窗口状态

使用 electron-win-state 可以保存窗口的状态，包括窗口的大小、位置、框架是否显示等。

[https://www.npmjs.com/package/electron-win-state](https://www.npmjs.com/package/electron-win-state)

```bash
npm i electron-win-state
```

main.js

```js
// 引入 electron-win-state
const WinState = require('electron-win-state').default // 由于 electron-win-state 没有做 commonjs 导出，所以需要使用 .default 引入

// 实例化 winState
const winState = new WinState({
  defaultWidth: 800,
  defaultHeight: 800
})

const createWindow = () => {
  const win = new BrowserWindow({
    ...winState.winOptions, // 将 winState.winOptions 传入 BrowserWindow
    backgroundColor: 'pink',
    webPreferences: {
      preload: path.resolve(__dirname, './preload.js')
    }
  })
  win.loadFile('index.html')
  winState.manage(win) // 设置 winState 管理 win 这个窗口
}
```

### webContents

#### 在主进程中监听页面加载完毕

通过 webContents.on('did-finish-load', () => {}) 可以监听页面加载完毕

> 注意：在引入外部图片资源的时候需要将安全策略中的图片调整为 *

index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- 在引入外部图片资源的时候需要将安全策略中的图片调整为 * -->
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; img-src * data:; script-src 'self'; style-src 'self' 'unsafe-inline'">
  <title>Title</title>
  <link rel="stylesheet" href="./app.css">
</head>
<body>
  <h1>hello</h1>
  <button id="btn">send</button>
  <div>
    <img src="https://i0.hdslb.com/bfs/new_dyn/b4602eb83106a81e7c446a58459e2adb286254503.jpg@1192w.avif" alt="">
  </div>
  <script src="./renderer/app.js"></script>
</body>
</html>
```

main.js

```js
const createWindow = () => {
  const win = new BrowserWindow({
    ...winState.winOptions,
    backgroundColor: 'pink',
    webPreferences: {
      preload: path.resolve(__dirname, './preload.js')
    }
  })
  win.loadFile('index.html')
  winState.manage(win)
  const wc = win.webContents
  // 监听页面加载完毕
  wc.on('did-finish-load', ()=>{
    console.log('页面加载好了')
  })
}
```

#### 在主进程中监听 dom 加载完毕

通过 webContents.on('dom-ready', () => {}) 可以监听 dom 加载完毕

main.js

```js
const createWindow = () => {
  const win = new BrowserWindow({
    ...winState.winOptions,
    backgroundColor: 'pink',
    webPreferences: {
      preload: path.resolve(__dirname, './preload.js')
    }
  })
  win.loadFile('index.html')
  winState.manage(win)
  const wc = win.webContents
  // 监听页面加载完毕
  wc.on('did-finish-load', () => {
    console.log('页面加载好了')
  })
  // 监听 dom 加载完毕
  wc.on('dom-ready', () => {
    console.log('dom 加载好了')
  })
}
```

[![pEQ6Mod.png](https://s21.ax1x.com/2025/02/20/pEQ6Mod.png)](https://imgse.com/i/pEQ6Mod)

#### 在主进程中监听是否打开了一个新窗口

通过 webContents.on('new-window', () => {}) 可以监听是否打开了一个新窗口

#### 在主进程中监听右键的上下文信息

通过 webContents.on('context-menu', (event, params) => {}) 可以监听右键的上下文信息

1. event：事件对象
2. params：上下文信息

main.js

```js
const createWindow = () => {
  const win = new BrowserWindow({
    ...winState.winOptions,
    backgroundColor: 'pink',
    webPreferences: {
      preload: path.resolve(__dirname, './preload.js')
    }
  })
  win.loadFile('index.html')
  winState.manage(win)
  const wc = win.webContents
  wc.on('dom-ready', () => {
    console.log('dom 加载好了')
  })
  wc.on('did-finish-load', () => {
    console.log('页面加载好了')
  })
  // 监听右键点击事件
  wc.on('context-menu', (e, params) => {
    console.log('点击了鼠标右键')
    console.log(e)
    console.log('===> params 参数', params)
  })
}
```

[![pEQ6doj.png](https://s21.ax1x.com/2025/02/20/pEQ6doj.png)](https://imgse.com/i/pEQ6doj)

> 应用场景：如果用户想要保存图片，就可以通过右键的上下文信息来获取图片的 url，然后通过 nodejs 的 fs 模块来保存图片。

#### 往页面中注入 js

webContents.executeJavaScript() 可以在 web 中执行 js 代码

```js
wc.executeJavaScript(`
  fetch('https://jsonplaceholder.typicode.com/users/1')
  .then(res => res.json())
  .catch(error => {
    alert(error)
  })
`, true).then((result) => {
  if (result) {
    console.log(result) // 打印 fetch 的结果
  } else {
    console.log('Fetch 请求获取数据失败')
  }
}).catch((error) => {
  console.error('执行 js 代码失败', error)
})
```

## dialog对话框

显示用于打开和保存文件、警报等的本机系统对话框

### 打开文件对话框

#### 异步

dialog.showOpenDialog([window, ] { options }).then(() => {})

**参数**：

1. **window (可选)**：
类型: BrowserWindow
描述: 指定对话框所属的窗口。如果省略，对话框将显示为应用程序的模态对话框。
2. **options**：
类型: Object
描述: 配置对话框的行为和外观。常见的选项包括：

    - **title** `string` (可选)： 对话框的标题。
    - **defaultPath** `string` (可选)： 对话框打开时的默认路径。
    - **buttonLabel** `string` (可选)： 确认按钮的标签，默认为 "Open"。
    - **filters** `FileFilter[]` (optional)： 文件类型过滤器，用于限制用户只能选择特定类型的文件。
    - **properties** `string[]` (可选)： 控制对话框的行为，例如：
      - **openFile**： 允许选择文件。
      - **openDirectory**： 允许选择目录。
      - **multiSelections**： 允许选择多个文件或目录。
      - **showHiddenFiles**： 显示隐藏文件。
      - **createDirectory**： 允许用户创建新目录（macOS）。
      - **promptToCreate**： 如果用户输入的文件路径不存在，提示用户创建文件（Windows）。
      - **dontAddToRecent**： 不将选择的文件添加到最近使用的文件列表中（Windows）。
    - **message** `string` (可选)：macOS _-显示在输入框上方的消息。
    - **securityScopedBookmarks** `boolean` (可选)：macOS MAS - 在打包提交到Mac App Store时创建 security scoped bookmarks

**返回值**：

返回 Promise\<Object> - resolve包含以下内容的object：

- **canceled** `boolean` - 对话框是否被取消。
- **filePaths** `string[]` - 用户选择的文件路径的数组. 如果对话框被取消，这将是一个空的数组。
- **bookmarks** `string[]` (optional) macOS MAS - 一个数组， filePaths 数组，base64编码字符串包含安全范围书签数据。 securityScopedBookmarks 必须启用才能捕获数据。 (返回值见 这里的表格。)

```js
// 从 electron 中引入 dialog
const { app, BrowserWindow, dialog } = require('electron')
const path = require('path')

const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    backgroundColor: 'pink',
    webPreferences: {
      preload: path.resolve(__dirname, './preload.js'),
    },
  })
  win.loadFile('index.html')

  const wc = win.webContents
  // 鼠标点击右键后打开文件选择框
  wc.on('context-menu', () => {
    dialog
      .showOpenDialog({
        buttonLabel: 'ok',
        defaultPath: app.getPath('desktop'),
        properties: ['multiSelections', 'createDirectory', 'openFile'],
        // filters 指定一个文件类型数组，用于规定用户可见或可选的特定类型范围。
        // extensions 数组应为没有通配符或点的扩展名 (例如, "png" 是正确的, 而 ".png" 和 *. png " 就是错误的)。 若要显示所有文件, 使用 "*" 通配符
        filters: [
          { name: 'Images', extensions: ['jpg', 'png', 'gif'] },
          { name: 'Movies', extensions: ['mkv', 'avi', 'mp4'] },
          { name: 'Custom File Type', extensions: ['as'] },
          { name: 'All Files', extensions: ['*'] },
        ],
      })
      .then((res) => {
        console.log(res)
      })
  })
}
```

> **注意:**在 Windows 和 Linux 上, 打开对话框不能同时是文件选择器和目录选择器, 因此如果在这些平台上将 properties 设置为["openFile"、"openDirectory"], 则将显示为目录选择器。

[![pEl98yt.png](https://s21.ax1x.com/2025/02/21/pEl98yt.png)](https://imgse.com/i/pEl98yt)

#### 同步

dialog.showOpenDialogSync([window, ] { options })

传入的参数和异步的一样，但是返回值不同

**返回值**：
类型: String[] 或 undefined
描述: 返回用户选择的文件或目录路径数组。如果用户取消对话框，则返回 undefined。

```js
const wc = win.webContents
// 鼠标点击右键后打开文件选择框
wc.on('context-menu', () => {
  const dialogRes = dialog
    .showOpenDialogSync({
      buttonLabel: 'ok', // 确认按钮的按钮文字
      defaultPath: app.getPath('desktop'), // 默认打开的路径
      // 可以操作的属性
      // multiSelections 可以多选文件
      // createDirectory 可以创建文件夹（mac）
      // openFile 允许选择文件
      // openDirectory 允许选择文件夹
      properties: ['multiSelections', 'createDirectory', 'openFile'],
      // filters 指定一个文件类型数组，用于规定用户可见或可选的特定类型范围。
      filters: [
        { name: 'Images', extensions: ['jpg', 'png', 'gif'] },
        { name: 'Movies', extensions: ['mkv', 'avi', 'mp4'] },
        { name: 'Custom File Type', extensions: ['as'] },
        { name: 'All Files', extensions: ['*'] },
      ],
    })
  
  console.log(dialogRes)
})
```

### 保存文件对话框

#### 异步

dialog.showSaveDialog([window, ] { options }).then(() => {})

**参数**：

1. **window（可选）**
类型: BrowserWindow
描述: 指定对话框所属的窗口。如果省略，对话框将显示为应用程序的模态对话框。
2. **options**
类型: Object
描述: 配置对话框的行为和外观。常见的选项包括：

    - **title** `string` (可选)：对话框标题。 无法在一些 Linux 桌面环境中显示。
    - **defaultPath** `string` (可选)：默认情况下使用的绝对目录路径、绝对文件路径或文件名。
    - **buttonLabel** `string` (可选)：「确认」按钮的自定义标签, 当为空时, 将使用默认标签。
    - **filters** `FileFilter[]` (optional)
    - **message** `string` (可选)：macOS _-显示在对话框上的消息。
    - **nameFieldLabel** `string` (可选)：macOS _ - 文件名输入框对应的自定义标签名。
    - **showsTagField** `boolean` (可选)：macOS - 显示标签输入框，默认为 true。
    - **properties** `string[]` (可选)
      - **showHiddenFiles**：显示对话框中的隐藏文件。
      - **createDirectory** macOS：允许你通过对话框的形式创建新的目录。
      - **treatPackageAsDirectory**：macOS _-将包 (如 .app 文件夹) 视为目录而不是文件。
      - **showOverwriteConfirmation**：Linux - 设置如果用户输入了已存在的文件名，是否会向用户显示确认对话框。
      - **dontAddToRecent**：Windows - 不要将正在保存的项目添加到最近的文档列表中。
      - **securityScopedBookmarks** `boolean` (可选)：macOS MAS - 在打包提交到Mac App Store时创建 security scoped bookmarks 当该选项被启用且文件尚不存在时，那么在选定的路径下将创建一个空文件。

**返回值**：

返回 Promise\<Object> - resolve包含以下内容的object：

- **canceled** `boolean`：对话框是否被取消。

- **filePath** `string`：If the dialog is canceled, this will be an empty string.
- **bookmark** `string(optional)` macOS MAS：包含了安全作用域的书签数据 Base64 编码的字符串来保存文件。 securityScopedBookmarks 必须启用才有效。

```js
const wc = win.webContents
  // 鼠标点击右键后打开文件选择框
wc.on('context-menu', (event, params) => {
  dialog
    .showSaveDialog({
      title: '保存你的垃圾文件',
      // 默认保存路径（绝对路径）
      defaultPath: path.join(app.getPath('desktop'), 'saveFile'),
      buttonLabel: '保存啊！',
    })
    .then((res) => {
      console.log(res)
    })
})
```

[![pElCx5F.png](https://s21.ax1x.com/2025/02/21/pElCx5F.png)](https://imgse.com/i/pElCx5F)

> 注意： 在macOS上，建议使用异步版本，以避免展开和折叠对话框时出现问题。

#### 同步

dialog.showSaveDialogSync([window, ]options)

参数和异步的一样，但是返回值不同

**返回值**：
类型: String
描述: 返回用户选择的文件的路径。如果用户取消保存，返回空字符串。

### 消息弹窗

#### 异步

dialog.showMessageBox([window, ]options)

**参数**：

1. **window（可选）**
类型: BrowserWindow
描述: 指定对话框所属的窗口。如果省略，对话框将显示为应用程序的模态对话框。
2. **options**
类型: Object
描述: 配置对话框的行为和外观。常见的选项包括：

    - **message** `string` - message box 的内容.
    - **type** `string` (可选)：可以为 none, info, error, question 或者 warning. 在 Windows 上, question 与info显示相同的图标, 除非你使用了 icon 选项设置图标。 在 macOS 上, warning 和 error 显示相同的警告图标
    - **buttons** `string`[] (可选)：按钮文本数组。 在 Windows上，一个空数组将导致按钮被标为“OK”。
    - **defaultId** `Integer` (可选)：在 message box 对话框打开的时候，设置默认选中的按钮，值为在 buttons 数组中的索引.
    - **signal** `AbortSignal` (可选)：通过 AbortSignal 信号实例可选地关闭消息框，消息框的行为就像用户点击取消一样。 在 macOS, signal 不适用于没有父窗口的消息框。因为平台限制，这些消息框同步运行
    - **title** `string` (可选)：message box 的标题，一些平台不显示.
    - **detail** `string` (可选)：额外信息.
    - **checkboxLabel** `string` (可选)：如果使用了，消息框将包含带有给定标签的复选框。
    - **checkboxChecked** `boolean` (可选)：checkbox 的初始值。 默认值为 false
    - **icon** `(NativeImage | string)` (optional)
    - **textWidth** `Integer` (可选) macOS：自定义消息框中文本的宽度
    - **cancelId** `Integer` (可选)：用于指定当用户按下 Esc 键 或 关闭对话框 时，应该返回哪个按钮的索引。如果不设置 cancelId，默认情况下，按下 Esc 键或关闭对话框会返回 0（即第一个按钮的索引）。
    - **noLink** `boolean` (可选)：用于指定是否将对话框中的链接文本（如 URLs 或文件路径）显示为可点击的链接。默认为 true
    - **normalizeAccessKeys** `boolean` (可选)：规范跨平台的键盘访问键。 默认值为 false. 用 & 连接和转换键盘访问键, 以便它们在每个平台上正常工作.& 字符会在macOS上被删除，在 Linux 上会被转换为 _，在 Windows 上保持不变。 例如 Vie&w 的按钮标签在 Linux 上会被转换为 Vie_w，在 macOS 转换为 View 并且可以被选择。而Windows和Linux上表示 Alt-W 。

**返回值**：
异步版本返回一个 Promise，解析为一个包含以下属性的对象：

- **response** `number`：点击的按钮的索引。
- **checkboxChecked** `boolean`：如果设置了 checkboxLabel，返回复选框是否被选中的状态。 否则，返回 false。

```js
const wc = win.webContents
// 鼠标点击右键后打开消息弹窗
wc.on('context-menu', () => {
  dialog
    .showMessageBox({
      title: '那我问你',
      message: '你可以打开这个链接吗？',
      type: 'info',
      buttons: ['666', '钝角', '确定', '取消'],
      defaultId: 1,
      detail: '这是一个秘密',
      checkboxLabel: '记住我',
      checkboxChecked: true,
      cancelId: 3,
    })
    .then((res) => {
      console.log(res)
    })
})
```

[![pEleWbd.png](https://s21.ax1x.com/2025/02/22/pEleWbd.png)](https://imgse.com/i/pEleWbd)

#### 同步

dialog.showSaveDialogSync([window, ]options)

参数和异步的一样，但是返回值不同

**返回值**：
类型: Integer
描述: 点击的按钮的索引。

### 错误信息弹窗

显示一个显示错误消息的模态对话框。
dialog.showErrorBox(title, content)

**参数**：

1. **title** `string` - 错误对话框的标题
2. **content** `string` - 错误对话框的内容

> 这个API可以在 app 模块触发 ready 事件之前被安全地调用，它通常用在启动时报告错误。 在 Linux 上, ready 事件之前调用这个API, 消息将被发送到stderr, 并且不会出现GUI对话框。

```js
const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    backgroundColor: 'pink',
    webPreferences: {
      preload: path.resolve(__dirname, './preload.js'),
    },
  })
  win.loadFile('index.html')

  const wc = win.webContents
  // 鼠标点击右键后打开错误弹窗
  wc.on('context-menu', () => {
    dialog.showErrorBox('右键报错', '123456')
  })
}

// 这个API可以在 app 模块触发 ready 事件之前被安全地调用，它通常用在启动时报告错误
// 在 Linux 上, ready 事件之前调用这个API, 消息将被发送到stderr, 并且不会出现GUI对话框。
dialog.showErrorBox('错误弹窗', '666')

app.whenReady().then(() => {
  createWindow()
})
```

[![pEleRDH.png](https://s21.ax1x.com/2025/02/22/pEleRDH.png)](https://imgse.com/i/pEleRDH)

## 剪切板

在使用剪切板时需要从 electron 中引入 clipboard

```js
const { clipboard } = require('electron')
```

### readText

用于从系统剪贴板中读取文本内容。

clipboard.readText([type])

**参数**：

- **type** `string` (可选)：指定剪贴板的类型。
  - **clipboard**：默认值，表示系统剪贴板。
  - **selection**：在某些 Linux 系统上，表示当前选中的文本（通常用于鼠标中键粘贴）。

**返回值**：
类型：string
描述：返回剪贴板中的文本内容。如果剪贴板中没有文本，则返回空字符串。

结合进程通信来实现在主进程和渲染进程中获取剪切板中的内容，clipboard 模块只能在主进程中使用，所以需要通过主进程来代理剪切板功能

app.js

```js
document.querySelector('#btn').addEventListener('click', () => {
  myApi.readClipBoardText()
})
```

preload.js

```js
const { contextBridge, ipcRenderer } = require('electron')

const readClipBoardText = async ()=>{
  const res = await ipcRenderer.invoke('read-clipboard')
  console.log('===> 预加载脚本：', res)
}

contextBridge.exposeInMainWorld('myApi', {
  readClipBoardText,
})
```

main.js

```js
ipcMain.handle('read-clipboard', (event, arg) => {
  const readRes = clipboard.readText('clipboard')
  console.log('===> 主进程：', readRes)
  return readRes
})

// 我复制了这段内容
```

[![pElm8Zd.png](https://s21.ax1x.com/2025/02/22/pElm8Zd.png)](https://imgse.com/i/pElm8Zd)

### writeText

用于向系统剪贴板中写入文本内容。

clipboard.writeText(text[, type])

**参数**：

- **text** `string`：要写入剪贴板的文本内容。
- **type** `string` (可选)：指定剪贴板的类型。
  - **clipboard**：默认值，表示系统剪贴板。
  - **selection**：在某些 Linux 系统上，表示当前选中的文本（通常用于鼠标中键粘贴）。

```js
const wc = win.webContents
// 鼠标点击右击打印剪切板中复制的内容
wc.on('context-menu', () => {
  const text = '向剪切板中写入内容'
  clipboard.writeText(text, 'clipboard')
  console.log(clipboard.readText('clipboard')) // 打印刚才写入的内容
})
```
