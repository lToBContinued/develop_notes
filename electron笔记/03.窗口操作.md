# 窗口操作

## BrowserWindow

BrowserWindow 类暴露了各种方法来修改应用窗口的外观和行为。

### 创建实例

main.js

```js
const { BrowserWindow } = require('electron')

const createWindow = () => {
  const win = new BrowserWindow() // 创建一个窗口实例
}
```

窗口可以实例化多个

```js
const { app, BrowserWindow, ipcMain } = require('electron')

const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    backgroundColor: 'pink',
  })
  win.loadFile('index.html')
  
  const win2 = new BrowserWindow({
    width: 600,
    height: 400
  })
  win2.loadURL('https://www.bilibili.com')
}
```

[![pEKfrYd.png](https://s21.ax1x.com/2025/02/16/pEKfrYd.png)](https://imgse.com/i/pEKfrYd)

### 优雅的显示窗口

#### 使用 ready-to-show 事件

当我们使用 win.loadUrl 或者 win.loadFile 加载一个页面时，在页面加载完成之前就会打开窗口，会产生一段时间的白屏，为了优化体验，我们可以使用 ready-to-show 事件来优雅的显示窗口。

**ready-to-show**事件：当页面已经渲染完成(但是还没有显示) 并且窗口可以被显示时触发

main.js

```js
const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    show: false, // 1. 先不显示窗口
  })

  win.loadURL('https://www.github.com')
  // 2. 等窗口中的内容加载完成后再显示窗口
  win.on('ready-to-show', () => {
    win.show()
  })
}
```

#### 设置 backgroundColor 属性

main.js

```js
const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    backgroundColor: '#6435c9',
  })

  // win.loadURL('https://www.bilibili.com')
  win.loadFile('index.html')
}
```

[![pEKfwwD.png](https://s21.ax1x.com/2025/02/16/pEKfwwD.png)](https://imgse.com/i/pEKfwwD)

### 父子窗口

main.js

```js
const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    backgroundColor: 'pink',
  })
  win.loadFile('index.html')
  
  const win2 = new BrowserWindow({
    width: 600,
    height: 400,
    parent: win, // 建立父子关系
  })
  win2.loadURL('https://www.bilibili.com')
}
```

> 建立父子关系的窗口在关闭父窗口时会自动关闭子窗口。

### 模态窗口

```js
const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    backgroundColor: 'pink',
  })
  win.loadFile('index.html')
  
  const win2 = new BrowserWindow({
    width: 600,
    height: 400,
    parent: win,
    modal: true, // 模态窗口
  })
  win2.loadURL('https://www.bilibili.com')
}
```

> 在关闭模态窗口前，不能操作父窗口。

### 原生的窗口框架

frame 是 BrowserWindow 的一个选项，用于控制浏览器窗口是否显示原生的窗口框架（包括标题栏、边框和窗口控制按钮，如最小化、最大化和关闭按钮）

```js
const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    frame: false, // 不显示窗口的默认边框
    backgroundColor: 'pink',
  })
  win.loadFile('index.html')
}
```

[![pEKfclt.png](https://s21.ax1x.com/2025/02/16/pEKfclt.png)](https://imgse.com/i/pEKfclt)

注意：设置 frame 为 false 后窗口无法拖动，此时可以通过 css 来解决

app.css

```css
html {
    height: 100%; /* 让html高度为100% */
}

body {
    margin: 0;
    padding: 0;
    height: 100%; /* 让body高度为100% */
    border: 1px solid red;
    -webkit-app-region: drag; /* 允许拖动 */
}

/* 其它的元素要设置禁止拖动，不然会产生一些和窗口可以拖动的冲突的bug */
button,
input {
    -webkit-app-region: no-drag; /* 禁止拖动 */
}
```

在 index.html 中引入

```html
<link rel="stylesheet" href="./app.css">
```

### 静态方法

#### getAllWindows()

**BrowserWindow.getAllWindows()**：所有打开的窗口的数组

#### getFocusedWindow()

**BrowserWindow.getFocusedWindow()**：返回此应用程序中当前获得焦点的窗口，如果无就返回 null

### 保存窗口状态

使用 electron-win-state 可以保存窗口的状态，包括窗口的大小、位置、框架是否显示等。

[https://www.npmjs.com/package/electron-win-state](https://www.npmjs.com/package/electron-win-state)

```bash
npm i electron-win-state
```

main.js

```js
// 引入 electron-win-state
const WinState = require('electron-win-state').default // 由于 electron-win-state 没有做 commonjs 导出，所以需要使用 .default 引入

// 实例化 winState
const winState = new WinState({
  defaultWidth: 800,
  defaultHeight: 800
})

const createWindow = () => {
  const win = new BrowserWindow({
    ...winState.winOptions, // 将 winState.winOptions 传入 BrowserWindow
    backgroundColor: 'pink',
    webPreferences: {
      preload: path.resolve(__dirname, './preload.js')
    }
  })
  win.loadFile('index.html')
  winState.manage(win) // 设置 winState 管理 win 这个窗口
}
```

## webContents

### 在主进程中监听页面加载完毕

通过 webContents.on('did-finish-load', () => {}) 可以监听页面加载完毕

> 注意：在引入外部图片资源的时候需要将安全策略中的图片调整为 *

index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- 在引入外部图片资源的时候需要将安全策略中的图片调整为 * -->
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; img-src * data:; script-src 'self'; style-src 'self' 'unsafe-inline'">
  <title>Title</title>
  <link rel="stylesheet" href="./app.css">
</head>
<body>
  <h1>hello</h1>
  <button id="btn">send</button>
  <div>
    <img src="https://i0.hdslb.com/bfs/new_dyn/b4602eb83106a81e7c446a58459e2adb286254503.jpg@1192w.avif" alt="">
  </div>
  <script src="./renderer/app.js"></script>
</body>
</html>
```

main.js

```js
const createWindow = () => {
  const win = new BrowserWindow({
    ...winState.winOptions,
    backgroundColor: 'pink',
    webPreferences: {
      preload: path.resolve(__dirname, './preload.js')
    }
  })
  win.loadFile('index.html')
  winState.manage(win)
  const wc = win.webContents
  // 监听页面加载完毕
  wc.on('did-finish-load', ()=>{
    console.log('页面加载好了')
  })
}
```

### 在主进程中监听 dom 加载完毕

通过 webContents.on('dom-ready', () => {}) 可以监听 dom 加载完毕

main.js

```js
const createWindow = () => {
  const win = new BrowserWindow({
    ...winState.winOptions,
    backgroundColor: 'pink',
    webPreferences: {
      preload: path.resolve(__dirname, './preload.js')
    }
  })
  win.loadFile('index.html')
  winState.manage(win)
  const wc = win.webContents
  // 监听页面加载完毕
  wc.on('did-finish-load', () => {
    console.log('页面加载好了')
  })
  // 监听 dom 加载完毕
  wc.on('dom-ready', () => {
    console.log('dom 加载好了')
  })
}
```

[![pEQ6Mod.png](https://s21.ax1x.com/2025/02/20/pEQ6Mod.png)](https://imgse.com/i/pEQ6Mod)

### 在主进程中监听是否打开了一个新窗口

通过 webContents.on('new-window', () => {}) 可以监听是否打开了一个新窗口

### 在主进程中监听右键的上下文信息

通过 webContents.on('context-menu', (event, params) => {}) 可以监听右键的上下文信息

1. event：事件对象
2. params：上下文信息

main.js

```js
const createWindow = () => {
  const win = new BrowserWindow({
    ...winState.winOptions,
    backgroundColor: 'pink',
    webPreferences: {
      preload: path.resolve(__dirname, './preload.js')
    }
  })
  win.loadFile('index.html')
  winState.manage(win)
  const wc = win.webContents
  wc.on('dom-ready', () => {
    console.log('dom 加载好了')
  })
  wc.on('did-finish-load', () => {
    console.log('页面加载好了')
  })
  // 监听右键点击事件
  wc.on('context-menu', (e, params) => {
    console.log('点击了鼠标右键')
    console.log(e)
    console.log('===> params 参数', params)
  })
}
```

[![pEQ6doj.png](https://s21.ax1x.com/2025/02/20/pEQ6doj.png)](https://imgse.com/i/pEQ6doj)

> 应用场景：如果用户想要保存图片，就可以通过右键的上下文信息来获取图片的 url，然后通过 nodejs 的 fs 模块来保存图片。

### 往页面中注入 js

webContents.executeJavaScript() 可以在 web 中执行 js 代码

```js
wc.executeJavaScript(`
  fetch('https://jsonplaceholder.typicode.com/users/1')
  .then(res => res.json())
  .catch(error => {
    alert(error)
  })
`, true).then((result) => {
  if (result) {
    console.log(result) // 打印 fetch 的结果
  } else {
    console.log('Fetch 请求获取数据失败')
  }
}).catch((error) => {
  console.error('执行 js 代码失败', error)
})
```
