# 进程

electron 中有两个进程：**主进程**和**渲染进程**

1. **主进程**：启动项目时运行的 main.js 文件就是我们说的主进程。在主进程运行的脚本可以以创建 web 页面的形式展示 GUI。**主进程只有一个**。
2. **渲染进程**：每个 electron 的页面都在运行着自己的进程，这样的进程称之为渲染进程（基于 chromium 的多进程结构）

[![pEnBznI.png](https://s21.ax1x.com/2025/02/10/pEnBznI.png)](https://imgse.com/i/pEnBznI)

主进程使用 BrowserWindow 创建实例，主进程销毁后，对应的渲染进程会被终止。主进程与渲染进程通过 IPC 方式（事件驱动）进行通信。

## 主进程

### 主进程生命周期

#### 所有窗口被关闭 window-all-closed

window-all-closed

在 Windows 和 Linux 上，我们通常希望在关闭一个应用的所有窗口后让它退出。

```js
app.on('window-all-closed', () => {
  // 当所有窗口都被关闭时，执行以下代码
  if (process.platform !== 'darwin') {
    // 如果当前平台不是 macOS（darwin），则退出应用程序
    app.quit()
  }
})
```

#### 窗口的打开 activate

activate

与前二者相比，即使没有打开任何窗口，macOS 应用通常也会继续运行。在没有窗口可用时调用 app 会打开一个新窗口。

因为窗口无法在 ready 事件前创建，你应当在你的应用初始化后仅监听 activate 事件。 要实现这个，仅监听 whenReady() 回调即可。

```js
app.whenReady().then(() => {
  createWindow()

  app.on('activate', ()=>{
    // 当应用程序被激活时，执行以下代码
    if (BrowserWindow.getAllWindows().length === 0) {
      // 如果当前没有打开的窗口，则创建一个新窗口
      createWindow()
    }
  })
})
```

#### 窗口关闭事件

1. **before-quit**：在程序关闭窗口前被触发
2. **will-quit**：当所有窗口被关闭后被触发，同时应用程序将退出。
3. **quit**：在应用程序退出时被触发

main.js

```js
app.on('before-quit', () => {
  console.log('===> before-quit')
})

app.on('will-quit', () => {
  console.log('===> will-quit')
})

app.on('quit', () => {
  console.log('===> quit')
})
```

[![pEKR6Nd.png](https://s21.ax1x.com/2025/02/16/pEKR6Nd.png)](https://imgse.com/i/pEKR6Nd)

#### 焦点事件

1. **focus**：当窗口获得焦点时触发
2. **blur**：当窗口失去焦点时触发

```js
app.on('browser-window-focus', () => {
  console.log('===> browser-window-focus')
})

app.on('browser-window-blur', () => {
  console.log('===> browser-window-blur')
})
```

例如：当切屏到另一个应用或最小化应用时，会触发 blur 事件，再回到应用时触发 focus 事件。

### 主进程事件

#### quit

尝试关闭所有窗口 将首先发出 before-quit 事件。 如果所有窗口都已成功关闭, 则将发出 will-quit 事件, 并且默认情况下应用程序将终止。

```js
app.on('browser-window-blur', () => {
  console.log('===> browser-window-blur')
  // 应用失去焦点，3秒后退出
  setTimeout(() => {
    app.quit()
  }, 3000)
})

app.on('before-quit', () => {
  console.log('===> before-quit')
})

app.on('will-quit', () => {
  console.log('===> will-quit')
})

app.on('quit', () => {
  console.log('===> quit')
})
```

> 此方法会确保执行所有 beforeunload 和 unload 事件处理程序。 可以在退出窗口之前的 beforeunload 事件处理程序中返回 false 取消退出。

#### exit

所有窗口都将立即被关闭，而不询问用户，而且 before-quit 和 will-quit 事件也不会被触发。

```js
app.on('browser-window-blur', () => {
  console.log('===> browser-window-blur')
  setTimeout(() => {
    app.exit()
  }, 3000)
})
```

#### getPath

获取系统中的一些目录，返回 string - 与 name 关联的目录或文件的路径。 失败会抛出一个Error。

main.js

```js
console.log(app.getPath('desktop')) // D:\file\desktop
console.log(app.getPath('music')) // C:\Users\ToBContinued\Music
console.log(app.getPath('temp')) // C:\Users\TOBCON~1\AppData\Local\Temp
console.log(app.getPath('userData')) // C:\Users\ToBContinued\AppData\Roaming\electron-basics
```

## 预加载脚本

### 基本使用

Electron 的预加载脚本是在渲染进程中运行的一段 js 代码，用于在主进程和渲染进程之间建立安全的桥梁。

**作用**：

1. 暴露有限的 Node.js API：预加载脚本可以在渲染进程中安全地暴露部分 Node.js API 或自定义方法，避免直接访问全部 Node.js API 带来的安全隐患。
2. 进程间通信：通过预加载脚本，渲染进程可以与主进程进行通信，实现数据交换和功能调用。
3. 增强安全性：通过限制渲染进程的权限，预加载脚本能有效防止恶意代码的执行。

### 预加载脚本运行在渲染进程中

main.js

```js
const {app, BrowserWindow} = require('electron')
const path = require('path')

const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    webPreferences: {
      // 预加载脚本的引入路径必须是绝对路径
      preload: path.resolve(__dirname, './preload.js')
    }
  })
  win.webContents.openDevTools()
  win.loadFile('index.html')
}

app.whenReady().then(() => {
  createWindow()
})
```

preload.js

```js
console.log('预加载脚本') // 这行代码会在渲染进程中打印
```

[![pEKwTrn.png](https://s21.ax1x.com/2025/02/15/pEKwTrn.png)](https://imgse.com/i/pEKwTrn)

### contextBridge

contextBridge 是 Electron 提供的一个 API，用于安全地在主进程和渲染进程之间传递数据和功能。它的主要作用是解决 Electron 应用中的安全性问题，尤其是在启用 contextIsolation（上下文隔离）时。

使用 contextBridge 定义一个全局变量

preload.js

```js
const { contextBridge } = require('electron')

// 使用 contextBridge 暴露一个全局变量
contextBridge.exposeInMainWorld('myApi', {
  platform: process.platform
})
```

全局变量被保存在 window 对象中

```js
console.log(window.myApi)
console.log(window.myApi.platform)
```

[![pEK0SM9.png](https://s21.ax1x.com/2025/02/15/pEK0SM9.png)](https://imgse.com/i/pEK0SM9)

## 主进程与渲染进程通信

**ipcRenderer**：从渲染器进程到主进程的异步通信，可以从渲染进程向主进程发送信息，也可以接受从主进程传来的信息

**ipcMain**：从主进程到渲染进程的异步通信，可以从主进程向渲染进程发送信息，也可以接受从渲染进程传来的信息

### 渲染进程 -> 主进程

**ipcRenderer.invoke(channel, ...args)**：通过 channel 向主进程发送消息，并异步等待结果。

1. channel：发送消息的事件名称
2. ...args：发送的消息内容

preload.js

```js
// ipcRenderer 用于渲染进程向主进程发送消息和接收主进程返回的消息
const { contextBridge, ipcRenderer } = require('electron')

// 1. 在预加载脚本中定义一个发送消息的方法
const handleSend = async () => {
  // 4. handleSend 被调用，ipcRenderer.invoke 会向主进程发送消息，消息名字为 send-event，消息内容为 hahahaha，并异步等待主进程返回的消息
  // 6. 接收主进程返回的消息
  let fallback = await ipcRenderer.invoke('send-event', 'hahahaha')
  console.log(fallback)
}

contextBridge.exposeInMainWorld('myApi', {
  platform: process.platform,
  handleSend // 2. 暴露 handleSend 方法
})
```

app.js

```js
document.querySelector('#btn').addEventListener('click', () => {
  // 3. 调用 preload 暴露的方法，当点击按钮时，会调用 handleSend 方法
  // 使用 window 对象的时候，window 可以省略
  myApi.handleSend()
})
```

**ipcMain.handle(channel, listener)**：为一个 invokeable 的 IPC 添加一个handler。 每当一个渲染进程调用 ipcRenderer.invoke(channel, ...args) 时这个处理器就会被调用。

1. channel：监听的 invokeable 的事件名称
2. listener：监听的事件回调函数，接收两个参数：event 和 args，event 是事件对象，args 是从渲染进程发送过来的消息内容

main.js

```js
// ipcMain 用于主进程接收渲染进程发送的消息和返回的消息
const { app, BrowserWindow, ipcMain } = require('electron')
const path = require('path')

const createWindow = () => {
  const win = new BrowserWindow({
    width: 1000,
    height: 600,
    webPreferences: {
      preload: path.resolve(__dirname, './preload.js')
    }
  })
  win.webContents.openDevTools()
  win.loadFile('index.html')
}

app.whenReady().then(() => {
  createWindow()
})

// 5. 主进程中使用 ipcMain.handle 监听渲染进程中名为 send-event 的消息，并执行一个回调函数，并返回给渲染进程一个消息
ipcMain.handle('send-event', (event, arg) => {
  console.log(arg)
  return arg
})
```

[![pEKR874.png](https://s21.ax1x.com/2025/02/16/pEKR874.png)](https://imgse.com/i/pEKR874)
