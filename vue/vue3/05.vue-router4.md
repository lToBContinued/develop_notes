# vue-router4 路由基本使用

## 安装路由

使用 npm init vite@latest 创建的 vue 项目不包含路由，需要自己手动安装，使用 npm init vue@latest 创建的 vue 项目自带路由，无需手动安装

```bash
npm i vue-router -s
```

## 使用路由

1. 创建路由文件

创建路由文件 src/router/index.ts

```ts
import { createRouter, type RouteRecordRaw, createWebHistory } from 'vue-router'

// 路由配置项
const routes:Array<RouteRecordRaw> = [
  {
    path: '/',
    component:() => import('../components/login.vue')
  },
  {
    path: '/reg',
    component:() => import('../components/reg.vue')
  }
]

const router = createRouter({
  history: createWebHistory(), // 路由模式
  routes
})

export default router // 导出路由
```

> 在 components 中创建的组件也可以当做页面使用

2. 在 main.ts 文件中导入路由

```ts
import {createApp} from 'vue'
import App from './App.vue'
import router from './router' // 导入路由

const app = createApp(App)

app.use(router) // 使用路由

app.mount('#app')
```

3. 在 App.vue 中引入路由页面

```vue
<template>
  <div>
    <h1>小满zs</h1>
    <div>
      <!-- router-link 相当于 a 标签，点击可以跳转到指定页面 -->
      <router-link to="/">Login</router-link>
      <router-link to="/reg">Reg</router-link>
      <hr>
      <!-- 使用内置的 router-view 组件引入路由页面 -->
      <!-- router-view 组件可以放在任何位置，根据它摆放的位置不同，页面的排版也会不同 -->
      <router-view></router-view>
    </div>
  </div>
</template>
```

## 路由模式

### hash（哈希）模式

```ts
const router = createRouter({
  history: createWebHashHistory(), // 设置路由模式为哈希模式
  routes
})
```

[![pEZef9s.png](https://s21.ax1x.com/2025/02/01/pEZef9s.png)](https://imgse.com/i/pEZef9s)

hash 是 URL 中 hash(#) 及后面的部分，常用作锚点在页面中进行导航，改编 URL 中的 hash 部分不会引起页面刷新

[![pEZegAg.png](https://s21.ax1x.com/2025/02/01/pEZegAg.png)](https://imgse.com/i/pEZegAg)

通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：

1. 通过浏览器前进后退改变 URL
2. 通过 \<a> 标签改变 URL
3. 通过 window.location 改变 URL

[![pEZe2NQ.png](https://s21.ax1x.com/2025/02/01/pEZe2NQ.png)](https://imgse.com/i/pEZe2NQ)

### history 实现

```ts
const router = createRouter({
  history: createWebHistory(),
  routes
})
```

[![pEZeh3n.png](https://s21.ax1x.com/2025/02/01/pEZeh3n.png)](https://imgse.com/i/pEZeh3n)

history 模式通过 popstate 监听路由变化

[![pEZe4cq.png](https://s21.ax1x.com/2025/02/01/pEZe4cq.png)](https://imgse.com/i/pEZe4cq)

通过 history.pushState() 跳转路由

> history.pushState 不会被 popstate 监听到，因此通过此方法改变路由后，需要再刷新页面才能切换到对应页面

使用 history.pushState 跳转

[![pEZmfaD.png](https://s21.ax1x.com/2025/02/01/pEZmfaD.png)](https://imgse.com/i/pEZmfaD)

刷新页面

[![pEZmhIe.png](https://s21.ax1x.com/2025/02/01/pEZmhIe.png)](https://imgse.com/i/pEZmhIe)

## 命名路由

使用 name 给路由命名，这样在跳转路由时候可以直接使用路由的名称操作

```ts
import {createRouter, type RouteRecordRaw, createWebHashHistory} from 'vue-router'

const routes:Array<RouteRecordRaw> = [
  {
    path:'/',
    name: 'Login', // 给路由命名
    component:()=>import('../components/login.vue')
  },
  {
    path:'/reg',
    name: 'Reg', // 给路由命名
    component:()=>import('../components/reg.vue')
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router
```

相应的在 router-link 中给 to 传递的需要变成一个对象的形式

```vue
<template>
  <div>
    <h1>小满zs</h1>
    <div>
      <!-- 相应的在 router-link 中给 to 传递的需要变成一个对象的形式 -->
      <router-link :to="{ name: 'Login' }">Login</router-link>
      <span>&nbsp;</span>
      <router-link :to="{ name: 'Reg' }">Reg</router-link>
      <hr>
      <router-view></router-view>
    </div>
  </div>
</template>
```

## 编程式导航

使用 useRouter 这个钩子函数进行路由跳转

### 字符串跳转

在 push 方法中可以接受一个字符串，直接跳转到对应路由页面

```vue
<template>
  <div>
    <h1>小满zs</h1>
    <div>
      <!-- 传入路由的路径 -->
      <button @click="toPage('/')">Login</button>
      <button @click="toPage('/Reg')">Reg</button>
      <hr>
      <router-view></router-view>
    </div>
  </div>
</template>

<script setup lang="ts">
import {useRouter} from 'vue-router'

const router = useRouter()
const toPage = (url: string) => {
  // 字符串跳转方式
  router.push(url)
}
</script>
```

### 接收对象跳转

将所要跳转的路由地址写在对象的 path 属性中

```vue
<template>
  <div>
    <h1>小满zs</h1>
    <div>
      <button @click="toPage('/')">Login</button>
      <button @click="toPage('/Reg')">Reg</button>
      <hr>
      <router-view></router-view>
    </div>
  </div>
</template>

<script setup lang="ts">
import {useRouter} from 'vue-router'

const router = useRouter()
const toPage = (url: string) => {
  // 使用对象的写法
  router.push({
    path: url
  })
}
</script>
```

也可以使用命名式写法，此时需要使用的是路由的名字（name）

```vue
<template>
  <div>
    <h1>小满zs</h1>
    <div>
      <!-- 传入路由的名字 -->
      <button @click="toPage('Login')">Login</button>
      <button @click="toPage('Reg')">Reg</button>
      <hr>
      <router-view></router-view>
    </div>
  </div>
</template>

<script setup lang="ts">
import {useRouter} from 'vue-router'

const router = useRouter()
const toPage = (name: string) => {
  // 使用路由名字进行跳转
  router.push({
    name
  })
}
</script>
```

## 路由的历史记录

通过普通的跳转方式跳转路由页面，在浏览器上会留下历史记录，用户可以通过点击浏览器的前进和后退查看之间访问过的页面。但有时我们不想让用户查看之前访问过的页面，例如用户登录成功，进入到首页后，不应该让用户通过浏览器的返回功能再次返回到登录界面，此时需要对路由跳转进行改造

### router-link 取消历史记录的方式

给 router-link 加上 replace 属性，点击后不会留下历史记录

```vue
<template>
  <div>
    <h1>小满zs</h1>
    <div>
      <!--给 router-link 加上 replace 属性，点击后不会留下历史记录-->
      <router-link replace to="/" style="margin-right: 10px">Login</router-link>
      <router-link replace to="/Reg">Reg</router-link>

      <button @click="toPage('Login')">Login</button>
      <button @click="toPage('Reg')">Reg</button>
      <hr>
      <router-view></router-view>
    </div>
  </div>
</template>
```

### 编程式导航取消历史记录的方式

将 push 方法改成 replace 方法

```vue
<template>
  <div>
    <h1>小满zs</h1>
    <div>
      <button @click="toPage('Login')">Login</button>
      <button @click="toPage('Reg')">Reg</button>
      <hr>
      <router-view></router-view>
    </div>
  </div>
</template>

<script setup lang="ts">
import {useRouter} from 'vue-router'

const router = useRouter()
const toPage = (name: string) => {
  // 使用 replace 方法进行跳转，不会保留历史记录
  router.push({
    name
  })
}
</script>
```

### 历史记录的跳转

除了使用浏览器的前进、后退按钮，还可以使用 go 和 back 方法可以跳转历史记录

**router.go(n: number)**：传入一个数字，正数表示前进 n 条历史，负数表示回退 n 条历史

**router.back()**：不接收参数，表示回退最近的上一次历史

```vue
<template>
  <div>
    <h1>小满zs</h1>
    <div>
      <button style="margin-right: 10px" @click="toPage('PageA')">PageA</button>
      <button style="margin-right: 10px" @click="toPage('PageB')">PageB</button>
      <button style="margin-right: 10px" @click="toPage('PageC')">PageC</button>
      <button style="margin-right: 10px" @click="toPage('PageD')">PageD</button>
      <button style="margin-right: 10px" @click="next()">Next</button>
      <button style="margin-right: 10px" @click="prev()">Prev</button>
      <hr>
      <router-view></router-view>
    </div>
  </div>
</template>

<script setup lang="ts">
import {useRouter} from 'vue-router'

const router = useRouter()
const toPage = (name: string) => {
  router.push({
    name
  })
}
const next = () => {
  router.go(1)
}
const prev = () => {
  router.back()
}
</script>
```

## 路由传参

### query 传参

#### 传递参数

通过 query 属性传递参数，query 只接受对象形式的值

```vue
<template>
  <div>
    嘿嘿嘿！ 我是列表页面
  </div>
  <table cellspacing="0" class="table" border="1">
    <thead>
    <tr>
      <th>品牌</th>
      <th>价格</th>
      <th>操作</th>
    </tr>
    </thead>
    <tbody>
    <tr v-for="item in data" :key="item.id">
      <th>{{ item.name }}</th>
      <th>{{ item.price }}</th>
      <th>
        <button @click="toDetail(item)">详情</button>
      </th>
    </tr>
    </tbody>
  </table>
</template>

<script setup lang="ts">
import {data} from './list.json'
import {type LocationQueryRaw, useRouter} from 'vue-router'

interface Item extends LocationQueryRaw {
  name: string
  price: number
  id: number
}

const router = useRouter()
const toDetail = (item: Item) => {
  router.push({
    // 通过 query 传递参数
    query: item
  })
}
</script>
```

添加 path 属性，跳转到 /detail 页面并携带参数

```ts
const toDetail = (item: Item) => {
  router.push({
    path: '/detail',
    // 通过 query 传递参数
    query: item
  })
}
```

[![pEZKbs1.png](https://s21.ax1x.com/2025/02/01/pEZKbs1.png)](https://imgse.com/i/pEZKbs1)

#### 接收参数

在 /detail 页面使用 useRoute 钩子函数接收对应页面传递过来的参数

```vue
<template>
  <div>
    嘿嘿嘿！ 我是详情页面
  </div>
  <div>品牌：{{ route.query.name }}</div>
  <div>价格：{{ route.query.price }}</div>
  <div>ID：{{ route.query.id }}</div>
</template>

<script setup lang="ts">
import {useRoute} from 'vue-router'

const route = useRoute()
</script>
```

[![pEZKqqx.png](https://s21.ax1x.com/2025/02/01/pEZKqqx.png)](https://imgse.com/i/pEZKqqx)

### params 传参（动态路由参数）

在 vue-router4 中，parmas 只能用于动态路由参数，即在路由路径中定义的参数，而不能用于传递任意参数

需要改造路由，将接受参数的路由地址后面添加动态参数

```ts
{
  path: '/detail/:id/:name/:price',
  name: 'Detail',
  component: () => import('../components/reg.vue')
},
```

> 注意：/detail/:id/:name/:price 表示 id、name 和 price 都是必传参数，如果不传参数，也希望匹配，可以加可选符"?"

```ts
{
  path: '/detail/:id/:name?/:price?',
  name: 'Detail',
  component: () => import('../components/reg.vue')
},
```

使用 params 传参时，跳转路由时只能用 name，不能用 path。

传递参数：

```vue
<template>
  <div>
    嘿嘿嘿！ 我是列表页面
  </div>
  <table cellspacing="0" class="table" border="1">
    <thead>
    <tr>
      <th>品牌</th>
      <th>价格</th>
      <th>操作</th>
    </tr>
    </thead>
    <tbody>
    <tr v-for="item in data" :key="item.id">
      <th>{{ item.name }}</th>
      <th>{{ item.price }}</th>
      <th>
        <button @click="toDetail(item)">详情</button>
      </th>
    </tr>
    </tbody>
  </table>
</template>

<script setup lang="ts">
import {data} from './list.json'
import { type RouteParamsRawGeneric, useRouter} from 'vue-router'

interface Item extends RouteParamsRawGeneric {
  name: string
  price: number
  id: number
}

const router = useRouter()
const toDetail = (item: Item) => {
  router.push({
    name: 'Detail',
    // 通过 params 传递参数
    params: item
  })
}
</script>
```

接收参数：

```vue
<template>
  <div>
    嘿嘿嘿！ 我是详情页面
  </div>
  <div>品牌：{{ route.params.name }}</div>
  <div>价格：{{ route.params.price }}</div>
  <div>ID：{{ route.params.id }}</div>
</template>

<script setup lang="ts">
import {useRoute} from 'vue-router'

const route = useRoute()
</script>
```

[![pEZMpzd.png](https://s21.ax1x.com/2025/02/01/pEZMpzd.png)](https://imgse.com/i/pEZMpzd)

应用：

如果只传了一个 id 过来，可以通过传递过来的 id 查找对应的商品

```vue
<template>
  <div>
    嘿嘿嘿！ 我是详情页面
  </div>
  <div>品牌：{{ item?.name }}</div>
  <div>价格：{{ item?.price }}</div>
  <div>ID：{{ item?.id }}</div>
</template>

<script setup lang="ts">
import {useRoute} from 'vue-router'
import {data} from './list.json'

const route = useRoute()

// 通过路由中传递的 id 找到对应的商品
const item = data.find(item => item.id === +route.params.id)
</script>
```

[![pEZMAdf.png](https://s21.ax1x.com/2025/02/01/pEZMAdf.png)](https://imgse.com/i/pEZMAdf)

## 嵌套路由

将子路由写在父路由的 children 数组中

```ts
import {createRouter, type RouteRecordRaw, createWebHashHistory} from 'vue-router'

const routes: Array<RouteRecordRaw> = [
  {
    path: '/',
    component: () => import('../components/footer.vue'),
    children: [
      {
        path: '', // path 为空时会作为默认子路由渲染
        name: 'Login',
        component: () => import('../components/login.vue')
      },
      {
        path: 'reg', // path 路径可以加“/”（/reg），也可以不加
        name: 'Detail',
        component: () => import('../components/reg.vue')
      }
    ]
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router
```

在父路由的页面中使用 router-view 引入子路由页面

```vue
<template>
  <div>
    <!--使用 router-view 组件渲染子路由-->
    <router-view></router-view>
    <hr>
    <h1>我是父路由</h1>
    <div>
      <router-link to="/">Login</router-link>
      <router-link to="/reg" style="margin-left: 10px">Reg</router-link>
    </div>
  </div>
</template>
```

如果父路由的 path 的 / 后有值，则跳转的时候需要加上父路由的前缀

```ts
import {createRouter, type RouteRecordRaw, createWebHashHistory} from 'vue-router'

const routes: Array<RouteRecordRaw> = [
  {
    path: '/user', // 父路由的 “/” 后有其他值
    component: () => import('../components/footer.vue'),
    children: [
      {
        path: '',
        name: 'Login',
        component: () => import('../components/login.vue')
      },
      {
        path: 'reg',
        name: 'Detail',
        component: () => import('../components/reg.vue')
      }
    ]
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router
```

```vue
<template>
  <div>
    <router-view></router-view>
    <hr>
    <h1>我是父路由</h1>
    <div>
      <!-- 跳转的时候需要加上"/user" -->
      <router-link to="/user">Login</router-link>
      <router-link to="/user/reg" style="margin-left: 10px">Reg</router-link>
    </div>
  </div>
</template>
```

## 命名视图

**命名视图**允许在一个路由中定义多个视图（多个 router-view）。默认情况下，每个路由都会渲染到一个单一的 \<router-view> 中，但通过命名视图，可以在多个不同的 router-view 上渲染不同的组件。

### 使用方法

命名视图的路由写在 **components** 中，default 是默认展示的路由页面，并且我们可以给其他的路由页面进行命名。

```ts
import {createRouter, type RouteRecordRaw, createWebHashHistory} from 'vue-router'

const routes: Array<RouteRecordRaw> = [
  {
    path: '/',
    component: () => import('../components/root.vue'),
    children: [
      {
        path: '/user1',
        components: { // 使用命名视图，命名视图的路由写在 components 中
          default: () => import('../components/A.vue')
        }
      },
      {
        path: '/user2',
        components: {
          bbb: () => import('../components/B.vue'), // 给路由进行命名
          ccc: () => import('../components/C.vue')
        }
      }
    ]
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router
```

在父页面中使用命名路由

如果 router-view 中 name 为空，则默认展示 default 路由，如果有 name 名字，则展示 name 传入的那个路由

```vue
<template>
  <div>
    <router-link to="/user1">user1</router-link>
    <router-link to="/user2" style="margin-left: 10px">user2</router-link>
    <hr>
    <router-view></router-view>
    <router-view name="bbb"></router-view>
    <router-view name="ccc"></router-view>
  </div>
</template>
```

### 使用场景

1. 有两个 tab 页，它们展示的详情不一样，可以使用命名视图。
2. 一个页面有很多人去开发，又不想写组件，也可以使用这种方式。

## 路由重定向

### 使用默认路由重定向

```ts
import {createRouter, type RouteRecordRaw, createWebHashHistory} from 'vue-router'

const routes: Array<RouteRecordRaw> = [
  {
    path: '/',
    component: () => import('../components/root.vue'),
    children: [
      {
        path: '', // 子路由中的 path 路径不写，即默认路由，可以重定向到这个子路由页面
        components: {
          default: () => import('../components/A.vue')
        }
      },
      {
        path: '/user2',
        components: {
          bbb: () => import('../components/B.vue'),
          ccc: () => import('../components/C.vue')
        }
      }
    ]
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router
```

### redirect 重定向

如果子路由的 path 要求要有值，那么需要使用 redirect 重定向到子路由

```ts
import {createRouter, type RouteRecordRaw, createWebHashHistory} from 'vue-router'

const routes: Array<RouteRecordRaw> = [
  {
    path: '/',
    component: () => import('../components/root.vue'),
    redirect: '/user1', // 使用 redirect 重定向到 /user1
    children: [
      {
        path: '/user1',
        components: {
          default: () => import('../components/A.vue')
        }
      },
      {
        path: '/user2',
        components: {
          bbb: () => import('../components/B.vue'),
          ccc: () => import('../components/C.vue')
        }
      }
    ]
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router
```

redirect 有三种书写形式

1. 字符串形式

```ts
redirect: '/user1',
```

2. 对象形式

```ts
redirect: {
  path: '/user1'
  // name: 'User1'  也可以使用路由的名字
}
```

3. 回调函数形式

```ts
redirect: (to) => {
  console.log(to) // to 里面是父路由的信息
  return '/user1'
}
```

也可以返回对象的形式，并且可以传参

```ts
redirect: (to) => {
  console.log(to) // to 里面是父路由的信息
  return {
    path: '/user1',
    query: to.query
  }
},
```

## 路由别名

路由别名通过 alias: [] 添加，可以给路由起多个路径地址，但是访问的组件是同一个

```ts
import {createRouter, type RouteRecordRaw, createWebHashHistory} from 'vue-router'

const routes: Array<RouteRecordRaw> = [
  {
    path: '/',
    component: () => import('../components/root.vue'),
    alias: ['/root', '/root1', '/root2'], // alias 添加路由别名
    children: [
      {
        path: '/user1',
        components: {
          default: () => import('../components/A.vue')
        }
      },
      {
        path: '/user2',
        components: {
          bbb: () => import('../components/B.vue'),
          ccc: () => import('../components/C.vue')
        }
      }
    ]
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router
```

[![pEZU8Gq.png](https://s21.ax1x.com/2025/02/02/pEZU8Gq.png)](https://imgse.com/i/pEZU8Gq)
[![pEZUGR0.png](https://s21.ax1x.com/2025/02/02/pEZUGR0.png)](https://imgse.com/i/pEZUGR0)
[![pEZU3in.png](https://s21.ax1x.com/2025/02/02/pEZU3in.png)](https://imgse.com/i/pEZU3in)
