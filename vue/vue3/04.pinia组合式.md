# Pinia 组合式API快速入门

## 什么是Pinia

Pinia 是 Vue 的最新`状态管理工具`，是 Vuex 的`替代品`

1. 提供更简单的 API （去掉 mutation）
2. 提供符合组合式风格的 API（和 Vue3 新语法统一）
3. 去掉了 modules 的概念，每一个 store 都是一个独立的模块
4. 配合 TypeScript 更加友好，提供可靠的类型判断

## 手动添加 Pinia 到 Vue 项目

在实际开发项目的时候，关于 Pinia 的配置，可以在项目创建时自动添加

1. 使用 Vite 创建一个空的 Vue3 项目
   npm create vue@latest
2. `按照官方文档`安装 pinia 到项目中

```js
// main.js
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
const pinia = createPinia() // 创建pinia实例
const app = createApp(App) // 创建根实例
app.use(pinia) // pinia 插件安装配置
app.mount('#app') // 视图的挂载
```

## 定义 store

Store 使用 defineStore( ) 定义的，它的第一个参数要求是一个**独一无二的**名字

```vue
<script setup>
import { defineStore } from 'pinia'

// 你可以任意命名 `defineStore()` 的返回值，但最好使用 store 的名字，同时以 `use` 开头且以 `Store` 结尾。
// (比如 `useUserStore`，`useCartStore`，`useProductStore`)
// 第一个参数是你的应用中 Store 的唯一 ID。
export const useAlertsStore = defineStore('alerts', {
  // 其他配置...
})
</script>
```

例：

```js
// store/counter.js

import { defineStore } from 'pinia'
import { ref } from 'vue'

// 定义store
// defineStore('仓库的唯一标识',()=>{ ... })
export const useCountStore = defineStore('counter', () => {
  // useCountStore 是一个函数，在别的组件中需要以函数调用的方式使用
  // 声明数据 state - count
  const count = ref(100)

  // 可以声明不止一个数据 state - msg
  const msg = ref('hello pinia')

  // 暴露出count和msg
  return {
    count,
    msg,
  }
})
```

```vue
<!--App.vue-->

<script setup>
// 导入store
import { useCountStore } from '@/store/counter'

// 以使用函数的形式使用store，在组件中的使用方式也是一样
const counterStore = useCountStore()
console.log(counterStore)
</script>

<template>
  <div>
    <h3>根组件 - {{ counterStore.count }} - {{ counterStore.msg }}</h3>
  </div>
</template>
```

## action 和 computed 的基本语法

### action 同步实现

```js
// store/counter.js

import { defineStore } from 'pinia'
import { ref } from 'vue'

export const useCountStore = defineStore('counter', () => {
  const count = ref(100)

  // 声明操作数据的方法 action（普通函数就是action）
  const addCount = () => {
    count.value++
  }
  const subCount = () => {
    count.value--
  }

  const msg = ref('hello pinia')

  // 向外暴露store中的内容
  return {
    count,
    addCount,
    subCount,
    msg,
  }
})
```

```vue
<!--son1Com.vue-->
<script setup>
import { useCountStore } from '@/store/counter'
const counterStore = useCountStore()
</script>

<template>
  <div>
    我是son1 - {{ counterStore.count }} -
    <!--调用action中的方法-->
    <button @click="counterStore.addCount()">+</button>
  </div>
</template>
===========================================================================================
<!--son2Com-->
<script setup>
import { useCountStore } from '@/store/counter'
const counterStore = useCountStore()
</script>

<template>
  <div>
    我是son2 - {{ counterStore.count }} -
    <!--调用action中的方法-->
    <button @click="counterStore.subCount()">-</button>
  </div>
</template>
===========================================================================================
<!--App.vue-->
<script setup>
import Son1Com from '@/components/son1Com.vue'
import Son2Com from '@/components/son2Com.vue'
import { useCountStore } from '@/store/counter'

const counterStore = useCountStore()
console.log(counterStore)
</script>

<template>
  <div>
    <h3>根组件 - {{ counterStore.count }} - {{ counterStore.msg }}</h3>
    <Son1Com></Son1Com>
    <Son2Com></Son2Com>
  </div>
</template>
```

### getters

```js
import { defineStore } from 'pinia'
import { computed, ref } from 'vue'

export const useCountStore = defineStore('counter', () => {
  const count = ref(100)

  // 声明基于数据派生的计算属性 getters（computed）
  const double = computed(() => {
    return count.value * 2
  })

  return {
    count,
    double,
    msg,
  }
})
```

```vue
<!--son1Com.vue-->
<script setup>
import { useCountStore } from '@/store/counter'

const counterStore = useCountStore()
</script>

<template>
  <!--使用计算属性-->
  <div>
    我是son1 - {{ counterStore.double }}
    <button @click="counterStore.addCount()">+</button>
  </div>
</template>
```

### action 异步实现

#### 编写方式

异步 action 函数的写法和`组件中获取异步数据的写法完全一致`
例：

```js
// store/channel.js

import { defineStore } from 'pinia'
import { ref } from 'vue'
import axios from 'axios'

export const useChannelStore = defineStore('channel', () => {
  // 声明数据
  const channelList = ref([])
  // 声明操作数据的方法
  const getList = async () => {
    // 支持异步
    const {
      data: { data },
    } = await axios({
      url: 'http://geek.itheima.net/v1_0/channels',
    })
    channelList.value = data.channels
    console.log(data.channels)
  }

  return {
    channelList,
    getList,
  }
})
```

```vue
<!--App.vue-->
<script setup>
import { useChannelStore } from '@/store/channel'
const channelStore = useChannelStore()
</script>

<template>
  <div>
    <!--获取频道数据-->
    <button @click="channelStore.getList">获取频道数据</button>
    <ul>
      <!--渲染频道列表-->
      <li v-for="item in channelStore.channelList" :key="item.id">{{ item.name }}</li>
    </ul>
  </div>
</template>
```

## storeToRefs 方法

**场景：**在组件中直接解构 store 中拿过来的数据，不处理，数据会丢失响应式
例：

```js
import { defineStore } from 'pinia'
import { computed, ref } from 'vue'

export const useCountStore = defineStore('counter', () => {
  const count = ref(100)

  const addCount = () => {
    count.value++
  }
  const subCount = () => {
    count.value--
  }

  const double = computed(() => {
    return count.value * 2
  })

  const msg = ref('hello pinia')

  return {
    count,
    double,
    addCount,
    subCount,
    msg,
  }
})
```

```vue
<!--App.vue-->
<script setup>
import Son1Com from '@/components/son1Com.vue'
import Son2Com from '@/components/son2Com.vue'
import { useCountStore } from '@/store/counter'
const counterStore = useCountStore()

// 此时，直接解构，不处理，数据会丢失响应式
const { count, msg } = counterStore
</script>

<template>
  <div>
    <h3>
      根组件
      <!--直接使用结构后的数据，不是响应式的-->
      - {{ count }} - {{ msg }}
    </h3>
    <Son1Com></Son1Com>
    <Son2Com></Son2Com>
  </div>
</template>
===========================================================================================
<!--son1Com-->
<script setup>
import { useCountStore } from '@/store/counter'

const counterStore = useCountStore()
</script>

<template>
  <div>
    我是son1 - {{ counterStore.count }} - {{ counterStore.double }}
    <button @click="counterStore.addCount()">+</button>
  </div>
</template>
===========================================================================================
<!--son2Com-->
<script setup>
import { useCountStore } from '@/store/counter'
const counterStore = useCountStore()
</script>

<template>
  <div>我是son2 - {{ counterStore.count }} - <button @click="counterStore.subCount()">-</button></div>
</template>
```

**解决方法：**

```vue
<!--App.vue-->
<script setup>
import { storeToRefs } from 'pinia'
// ...其它代码
// 使用 storeToRefs(对象) 解构
const { count, msg } = storeToRefs(counterStore)
// 如果是action方法的话，可以直接从store中解构
const { addCount, subCount } = counterStore
</script>
```

## Pinia 持久化插件

官方文档：<https://prazdevs.github.io/pinia-plugin-persistedstate/zh/>

### 使用步骤

1. 安装依赖
   pnpm：pnpm i pinia-plugin-persistedstate
   npm：npm i pinia-plugin-persistedstate
   yarn：yarn add pinia-plugin-persistedstate
2. 将插件添加到 pinia 实例上

```js
// main.js
import { createApp } from 'vue'
import { createPinia } from 'pinia'
// 导入持久化插件
import persist from 'pinia-plugin-persistedstate'

const pinia = createPinia()
const app = createApp(App)
app.use(pinia.use(persist))
```

3. 在 store 中开启持久化

```js
// store.js
// 在 store 的第三个参数位置添加开启持久化代码
export const useCountStore = defineStore(
  'counter',
  () => {
    // ... 其他代码
  },
  {
    // 开启持久化
    persist: true,
  },
)
```

更多配置，例如：修改本地存储的唯一标识、指定哪些数据需要被持久化等可以看官网中的配置选项。

```js
// store.js
export const useCountStore = defineStore(
  'counter',
  () => {
    const count = ref(100)
    const msg = ref('hello pinia')
    // ... 其他代码
  },
  {
    persist: {
      key: 'hm-counter', // 修改本地存储的唯一标识
      paths: ['count'], // 存储的是哪些数据
    },
  },
)
```
