# 组合式API

## 组合式API - setup

**特点：**

1. 执行时机比 beforeCreated 还要早
2. setup 函数中获取不到 this，this 是 undefined（因为 setup 函数创建的时机比 beforeCreated 还要早）
3. 在 setup 中写的任何数据和函数必须 return，才能在模版中使用

```vue
<script>
export default {
  setup() {
    // 数据
    const message = 'this is message'
    // 函数
    const logMessage = () => {
      console.log(message)
    }
    return {
      message,
      logMessage,
    }
  },
}
</script>

<template>
  <!--使用方法和数据-->
  {{ message }}
  <button @click="logMessage">logMessage</button>
</template>
```

4.通过 `<script setup>` 语法糖简化代码

```vue
// 原始复杂写法
<script>
export default {
  setup() {
    // 数据
    const message = 'this is message'
    // 函数
    const logMessage = () => {
      console.log(message)
    }
    return {
      message,
      logMessage,
    }
  },
}
</script>

// 语法糖写法
<script setup>
// 数据
const message = 'this is message'
// 函数
const logMessage = () => {
  console.log(message)
}
</script>
```

## 组合式 API - reactive 和 ref 函数

### reactive( )

#### 作用

接收`对象类型数据的参数传入`并返回一个`响应式对象`

#### 核心步骤

1. 从 vue 包中导入`reactive`函数
2. 在 <script setup>中`执行 reactive 函数`并传入`类型为对象`的初始值，并使用变量接收返回值

```vue
<script setup>
// 导入
import { reactive } from 'vue'

// 执行函数 传入参数 变量接收
const state = reactive(对象类型数据)
</script>
```

### ref( )

#### 作用

接收`简单类型或者对象类型的数据`传入并返回一个`响应式的对象`

#### 核心步骤

1. 从 vue 包中导入`ref`函数
2. 在 \<script setup> 中`执行 ref 函数`并传入初始值，使用`变量接收`ref函数的返回值

```vue
<script setup>
// 导入
import { ref } from 'vue'

// 执行函数 传入参数 变量接收
const count = ref(简单类型或者复杂类型数据)
</script>
```

#### 本质

是在原有传入数据的基础上，外层包了一层对象（即使是传入的数组和对象也会再被包一层对象），包成了复杂类型
**底层，**包成复杂类型之后，再借助 reactive 实现的响应式
**注意点：**

1. `脚本中`访问数据，需要通过 .value
2. 在 `template 中`，.value不需要写（帮我们扒了一层）

```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)
// 脚本中访问数据，需要通过 .value
console.log(count.value)
const setCount = () => {
  count.value++
}
</script>

<template>
  <div>
    <!--在 template 中，.value不需要写-->
    <div>{{ count }}</div>
    <button @click="setCount">+1</button>
  </div>
</template>
```

### 推荐

以后声明数据，统一用 ref → 统一了编码规范

## 组合式API - computed

计算属性基本思想和 vue2 的完全一致，组合式API下的计算属性`只是修改了写法`

### 核心步骤

1. `导入` computed 函数
2. `执行函数`在回调参数中 `return 基于响应式数据做计算的值`，用`变量接收`

```vue
<script setup>
// 导入
import { computed } from 'vue'

// 执行函数 变量接收 在毁掉参数中return计算值
const computedState = computed(() => {
  return 基于响应式数据做计算后的值
})
</script>
```

完整写法：

```vue
<script>
import { ref, computed } from 'vue'

const count = ref(1)
const changeCount = computed({
  get: () => {
    return count.value + 1
  },
  set: (val) => {
    return (count.value = val - 1)
  },
})
changeCount.value = 5
console.log(count.value) // 4
</script>
```

**注意：**

1. 计算属性中不应该有“副作用”
   `比如异步请求/修改dom`
2. 避免直接修改计算属性的值
   `计算属性应该是只读的，特殊情况可以配置get set`

## 组合式API - watch

**作用：**侦听一个或者多个数据的变化，数据变化时执行回调函数
**两个额外参数：**1. immediate（立即执行） 2. deep（深度监听）

### 基础使用 - 侦听单个数据

1. `导入 watch` 函数
2. `执行 watch 函数`传入要侦听的响应式数据`（ref 对象）`和回调函数

```vue
<script setup>
// 1.导入watch
import { ref, watch } from 'vue'

const count = ref(1)

// 2.调用watch侦听变化
watch(count, (newValue, oldValue) => {
  console.log(`count发生了变化，老值为${oldValue}，新值为${newValue}`)
})
</script>
```

### 基础使用 - 侦听多个数据

```vue
<script setup>
// 1.导入watch
import { ref, watch } from 'vue'

const count = ref(1)
const name = ref('cp')

// 2.调用watch侦听变化
watch(
  // 将需要监听的数据作为数组传入
  [count, name],
  ([newCount, newName], [oldCount, oldVName]) => {
    console.log('count或者name发生了变化', [newCount, newName], [oldCount, oldVName])
  },
)
</script>
```

### immediate

**作用：**在侦听器创建时`立即触发回调`，响应式数据变化之后继续执行回调

```vue
<script setup>
watch(
  count,
  (newValue, oldValue) => {
    console.log(newValue, oldValue)
  },
  {
    immediate: true,
  },
)
</script>
```

### deep

deep 深度监视，默认 watch 进行的是浅层监视
const ref1 = ref(简单类型) 可以直接监视
const ref2 = ref(复杂类型) 监视不到复杂类型内部的数据变化

```vue
<script setup>
import { ref, watch } from 'vue'

const userInfo = ref({
  name: 'zs',
  age: 18,
})

const setUserInfo = () => {
  userInfo.value.age++
}

watch(
  userInfo,
  (newValue) => {
    console.log(newValue)
  },
  {
    deep: true,
  },
)
</script>
```

### 精确侦听对象的某个属性

需求：在不开启 deep 的情况下，侦听 age 的变化，只有 age 变化时才执行回调

```vue
<script setup>
import { ref, watch } from 'vue'

const userInfo = ref({
  name: 'zs',
  age: 18,
})

const setUserInfo = () => {
  userInfo.value.age++
  // userInfo.value.name = 'ls'
}

// 把第一个参数写成函数的写法，返回要监听的具体属性值
watch(
  () => userInfo.value.age,
  (newValue, oldValue) => {
    console.log(newValue, oldValue)
  },
)
</script>
```

## 组合式API - vue3的生命周期

|        选项式API        |     组合式API     |
| :---------------------: | :---------------: |
| `beforeCreated/created` |      `setup`      |
|       beforeMount       |   onBeforeMount   |
|         mounted         |     onMounted     |
|      beforeUpdate       |  onBeforeUpdate   |
|         updated         |     onUpdated     |
|     `beforeUnmount`     | `onBeforeUnmount` |
|       `unmounted`       |   `onUnmounted`   |

```vue
<script setup>
import { onMounted } from 'vue'

// beforeCreate 和 created 的相关代码一律放在 setup 中执行
const getList = () => {
  setTimeout(() => {
    console.log('发送请求，获取数据')
  }, 2000)
}
// 因为 setup 执行时机比 beforeCreated 还要早，而<script setup>是setup的语法糖简化代码，因此一进页面的请求可以直接写
getList()

// 如果有些代码需要在 mounted 生命周期中执行
onMounted(() => {
  console.log('mounted生命周期函数 - 逻辑1')
})

// 写成函数的调用方式，可以调用多次，并不会冲突，而是按照顺序依次执行
onMounted(() => {
  console.log('mounted生命周期函数 - 逻辑2')
})
</script>
```

## 组合式API下的父子通信

### 父传子

**基本思想：**

1. 父组件中给`子组件以绑定属性的方式传值`
2. 子组件内部通过`props选项接收`

```vue
<!--App.vue 父组件-->
<script setup>
// 引入子组件
import sonComVue from './son-com.vue'
</script>

<template>
  <!--1.绑定属性 message-->
  <sonComVue message="this is app message"></sonComVue>
</template>
===========================================================================================
<!--som-com.vue 子组件-->
<script setup>
// 2.通过defineProps "编译器宏"接收子组件传递的数据
const props = defineProps({
  message: String,
})
</script>

<template>
  {{ message }}
</template>
```

defineProps原理：就是编译阶段的一个表示，实际编辑器解析时，遇到后会进行编译转换

### 子传父

**基本思想：**

1. 父组件中给`子组件标签用过 @ 绑定事件`
2. 子组件内部通过 `emit 方法触发事件`

```vue
<!--App.vue 父组件-->
<script setup>
// 引入子组件
import sonComVue from './son-com.vue'

const getMessage = (msg) => {
  console.log(msg)
}
</script>

<template>
  <!--1.绑定自定义事件-->
  <sonComVue @get-message="getMessage"></sonComVue>
</template>
===========================================================================================
<!--son-com.vue 子组件-->
<script setup>
// 2.通过 defineEmits 编译器宏生成 emit 方法，任何在 emit 中触发的方法都需要在 defineEmits 中声明
const emit = defineEmits(['get-message'])

const sendMsg = () => {
  // 3.触发自定义事件 并传递参数
  emit('get-message', 'this is a message')
}
</script>

<template>
  <button @click="sendMsg">sendMsg</button>
</template>
```

## 组合式API - 模板引用

**模板引用的概念：**通过`ref标识`获取真实的`dom对象或者组件实例对象`

### 核心步骤

1. 调用 ref 函数生成一个 ref 对象
2. 通过 ref 标识绑定 ref 对象到标签

```vue
<script setup>
import TestCom from '@/components/test-com.vue'
import { onMounted, ref } from 'vue'

// 模版引用（可以获取dom，也可以获取组件）
// 获取 dom
// 1.调用ref函数生成ref对象
const inp = ref(null)

// 3.通过ref对象，value即可访问绑定的元素（必须渲染完成后，才能拿到）
// 生命周期钩子 onMounted，等 dom 渲染完
onMounted(() => {
  console.log(inp.value)
  inp.value.focus()
})

const clickFn = () => {
  inp.value.focus()
}
// -------------------------------
// 获取组件
const testRef = ref(null)

const getCom = () => {
  console.log(testRef.value)
}
</script>

<template>
  <div>
    <!--2.通过ref标识进行绑定-->
    <input ref="inp" type="text" />
    <button @click="clickFn">点击让输入框聚焦</button>
  </div>
  <TestCom ref="testRef"></TestCom>
  <button @click="getCom">获取组件</button>
</template>
===========================================================================================
<!--test-com.vue 组件-->
<script setup>
const count = 999
const sayHi = () => {
  console.log('打招呼')
}
</script>

<template>
  <div>我是用于测试的组件 - {{ count }}</div>
</template>
```

### defineExpose( )

默认情况下在 \<script setup> 语法糖下`组件内部的属性和方法是不开放`给父组件访问的，可以通过 defineExpose 编译宏`指定哪些属性和方法允许访问`

```vue
<script setup>
import TestCom from '@/components/test-com.vue'
import { onMounted, ref } from 'vue'

// 生成 ref 对象
const testRef = ref(null)

const getCom = () => {
  // 获取子组件中暴露出来的数据和使用的函数
  console.log(testRef.value.count) // 999
  testRef.value.sayHi() // 打招呼
}
</script>

<template>
  <TestCom ref="testRef"></TestCom>
  <button @click="getCom">获取组件</button>
</template>
===========================================================================================
<!--test-com.vue 组件-->
<script setup>
const count = 999
const sayHi = () => {
  console.log('打招呼')
}
defineExpose({
  count,
  sayHi,
})
</script>

<template>
  <div>我是用于测试的组件 - {{ count }}</div>
</template>
```

## 组合式API - provide和inject

### 作用和场景

顶层组件向任意的底层组件`传递数据和方法`，实现`跨层组件通信`

### 跨层传递普通数据

1. 顶层组件通过 `provide 函数提供`数据
2. 底层组件通过 `inject 函数获取`数据

```vue
<!--顶层组件-->
<script setup>
import CenterCom from '@/components/center-com.vue'
import { provide, ref } from 'vue'

// 1.跨层传递普通数据
provide('theme-color', 'pink')

// 2.跨层传递响应式数据
const count = ref(100)
provide('count', count)

setTimeout(() => {
  count.value = 500
}, 2000)

// 3.跨层级传递函数 => 给子孙后代传递可以修改数据的方法
provide('changeCount', (newValue) => {
  count.value = newValue
})
</script>

<template>
  <div>
    <h1>我是顶层组件</h1>
    <CenterCom></CenterCom>
  </div>
</template>
===========================================================================================
<!--中间组件-->
<script setup>
import BottomCom from '@/components/bottom-com.vue'
</script>

<template>
  <div>
    <h2>我是中间组件</h2>
    <BottomCom></BottomCom>
  </div>
</template>
===========================================================================================
<!--底层组件-->
<script setup>
import { inject } from 'vue'

// 获取顶层组件传递过来的数据
const themeColor = inject('theme-color')
const count = inject('count')
const changeCount = inject('changeCount')
// 底层组件只能通过顶层组件传递过来的函数来修改顶层组件的数据，本质还是顶层组件修改自己的数据
const clickFn = () => {
  changeCount(1000)
}
</script>

<template>
  <div>
    <h3>我是底层组件 - {{ themeColor }} - {{ count }}</h3>
    <button @click="clickFn">更新count</button>
  </div>
</template>
```

## 自定义指令

> Vue 中有 v-if,v-for,v-bind，v-show,v-model 等等一系列方便快捷的指令，但是我们也可以根据需求自定义一些其他的指令，来满足特定的行为

### 什么时候使用自定义指令

只有当所需功能只能通过直接的 DOM 操作来实现时，才应该使用自定义指令。一个常见例子是使元素获取焦点的 v-focus 指令。

```vue
<template>
  <input v-focus />
</template>

<script setup>
// 在模板中启用 v-focus
const vFocus = {
  mounted: (el) => el.focus()
}
</script>
```

> 建议尽可能使用 v-bind 等内置指令声明模板，因为它们更高效，对服务端渲染也更友好。

### vue3 生命周期钩子和参数

一个指令的定义对象可以提供几种钩子函数 (都是可选的)：

```vue
<script setup>
const myDirective = {
  // 在绑定元素的 attribute 前或事件监听器应用前调用
  created(el, binding, vnode) {
    // 下面会介绍各个参数的细节
  },
  // 在元素被插入到 DOM 前调用
  beforeMount(el, binding, vnode) {},
  // 在绑定元素的父组件及他自己的所有子节点都挂载完成后调用
  mounted(el, binding, vnode) {},
  // 绑定元素的父组件更新前调用
  beforeUpdate(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件及他自己的所有子节点都更新后调用
  updated(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载前调用
  beforeUnmount(el, binding, vnode) {},
  // 绑定元素的父组件卸载后调用
  unmounted(el, binding, vnode) {}
}
</script>
```

vue2 指令 bind inserted update componentUpdated unbind

1. **el**: 指令绑定到的元素。这可以用于直接操作 DOM。
2. **binding**：一个对象，包含以下属性：
   - value：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。
   - oldValue：之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。
   - arg：传递给指令的参数 (如果有的话)。例如在 v-my-directive:foo 中，参数是 "foo"。
   - modifiers：一个包含修饰符的对象 (如果有的话)。例如在 v-my-directive.foo.bar 中，修饰符对象是 { foo: true, bar: true }。
   - instance：使用该指令的组件实例。
   - dir：指令的定义对象。
3. **vnode**：当前元素的虚拟 DOM 也就是Vnode。
4. **prevVnode**：代表之前的渲染中指令所绑定元素的 VNode。仅在 beforeUpdate 和 updated 钩子中可用。

```vue
<template>
  <button @click="show = !show">开关{{ show }} ----- {{ title }}</button>
  <Dialog ref="dialogRef" v-change-color:name.bar.foo="{ background: show ? 'green' : 'red', flag: show }"></Dialog>
</template>

<script setup lang="ts">
import { type Directive, type DirectiveBinding, ref, type VNode } from 'vue'
import Dialog from '@/component/dialog.vue'

const show = ref(false)
const title = ref('标题')

const vChangeColor: Directive = {
  mounted(el, binding: DirectiveBinding, vnode: VNode) {
    console.log(el)
    console.log(binding)
    console.log(vnode)
  },
}
</script>
```

[![pEAdDW6.png](https://s21.ax1x.com/2025/01/22/pEAdDW6.png)](https://imgse.com/i/pEAdDW6)

### 在 setup 内定义局部指令

在 \<script setup> 中，任何以 v 开头的驼峰式命名的变量都可以当作自定义指令使用。

```vue
<template>
  <button @click="show = !show">开关{{ show }} ----- {{ title }}</button>
  <Dialog v-change-color="{ background: show ? 'green' : 'red', flag: show }"></Dialog>
</template>

<script setup lang="ts">
import { type Directive, type DirectiveBinding, ref } from 'vue'
import Dialog from '@/component/dialog.vue'

type Value = {
  background: string
  flag: boolean
}

const show = ref(false)
const title = ref('标题')

const vChangeColor: Directive = {
  created: () => {
    console.log('初始化====>')
  },
  beforeMount(...args: Array<any>) {
    // 在元素上做些操作
    console.log('初始化一次=======>')
    console.log(args)
  },
  mounted(el: HTMLElement, dir: DirectiveBinding<Value>) {
    el.style.background = dir.value.background
    console.log('初始化========>')
    console.log(dir)
    console.log(el)
  },
  beforeUpdate() {
    console.log('更新之前')
  },
  updated(el: HTMLElement, dir: DirectiveBinding<Value>) {
    el.style.background = dir.value.background
    console.log('更新结束')
  },
  beforeUnmount(...args: Array<any>) {
    console.log(args)
    console.log('======>卸载之前')
  },
  unmounted(...args: Array<any>) {
    console.log(args)
    console.log('======>卸载完成')
  },
}
</script>
```

在不使用 \<script setup> 的情况下，自定义指令需要通过 directives 选项注册：

```vue
<script>
export default {
  setup() {
    /*...*/
  },
  directives: {
    // 在模板中启用 v-highlight
    changeColor: {
      /* ... */
    }
  }
}
</script>
```

### 简写形式

> 对于自定义指令来说，一个很常见的情况是仅仅需要在 mounted 和 updated 上实现相同的行为，除此之外并不需要其他钩子。这种情况下我们可以直接用一个函数来定义指令。

```vue
<template>
  <div v-color="red" style="width: 100px; height: 100px;"></div>
</template>

<script setup lang='ts'>
import { type Directive, type DirectiveBinding } from 'vue'

const vColor: Directive = (el: HTMLElement, binding: DirectiveBinding) {
  el.style.color = binding.value
}
</script>
```

案例 1：用户权限控制

```vue
<template>
  <div class="btns">
    <button v-has-show="'shop:create'">创建</button>
    <button v-has-show="'shop:edit'">编辑</button>
    <button v-has-show="'shop:delete'">删除</button>
  </div>
</template>

<script setup lang="ts">
import type { Directive } from 'vue'

// 模拟保存的用户id
localStorage.setItem('userId', 'zhangsan')
// mock后台返回的用户权限数据
const permission = ['zhangsan:shop:edit', 'zhangsan:shop:delete']
// 获取用户id
const userId = localStorage.getItem('userId') as string

const vHasShow: Directive<HTMLElement, string> = (el, binding) => {
  if (!permission.includes(`${userId}:${binding.value}`)) {
    el.style.display = 'none'
  }
}
</script>
```

案例 2：指令拖拽

```vue
<template>
  <div v-move class="box">
    <div class="header"></div>
    <div>内容</div>
  </div>
</template>

<script setup lang="ts">
import type { Directive, DirectiveBinding } from 'vue'

const vMove: Directive<any, void> = (el: HTMLElement, binding: DirectiveBinding) => {
  let moveElement: HTMLDivElement = el.firstElementChild as HTMLDivElement
  const mouseDown = (e: MouseEvent) => {
    let X = e.clientX - el.offsetLeft
    let Y = e.clientY - el.offsetTop
    const move = (e: MouseEvent) => {
      el.style.left = e.clientX - X + 'px'
      el.style.top = e.clientY - Y + 'px'
    }
    document.addEventListener('mousemove', move)
    document.addEventListener('mouseup', () => {
      document.removeEventListener('mousemove', move)
    })
  }
  moveElement.addEventListener('mousedown', mouseDown)
}
</script>

<style scoped>
.box {
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 500px;
  height: 200px;
  background-color: #fff;
  border-radius: 5px;
  border: 1px solid #000;
  text-align: center;
}

.header {
  width: 100%;
  height: 30px;
  background-color: #000;
}
</style>
```

### 重要应用：图片懒加载

```vue
<template>
  <div>
    <img v-lazy="item" v-for="item in arr" :key="item" width="360" height="360" alt="" />
  </div>
</template>

<script setup lang="ts">
import { type Directive } from 'vue'

// 获取图片列表，实际开发中可以从后台获取
// glob 是懒加载的模式
// 加入 { eager: true } 变为静态加载
// let imageList = import.meta.glob('../../assets/images/*.*')
let imageList: Record<
  string,
  {
    default: string
  }
> = import.meta.glob('../../assets/images/*.*', { eager: true })
let arr = Object.values(imageList).map((item) => item.default)

let vLazy: Directive<HTMLImageElement, string> = async (el, binding) => {
  const def = await import('@/assets/icons/Vue.svg') // 图片没加载完成之前显示的图片
  el.src = def.default
  // 创建一个观察器，监听元素是否进入可视区域
  const observer = new IntersectionObserver((entry) => {
    if (entry[0].intersectionRatio > 0) {
      el.src = binding.value // 图片加载完成之后显示的图片
      observer.unobserve(el) // 图片加载完成后停止监听
    }
  }, {})
  // 开始监听
  observer.observe(el)
}
</script>
```

### 全局注册

定义自定义指令

```ts
/**
 * @description: 改变背景颜色
 * @example
 * <div v-change-color="'green'">内容</div>
 */

import type { DirectiveBinding } from 'vue'

export default {
  install(app) {
    app.directive('change-color', {
      mounted(el: HTMLElement, binding: DirectiveBinding) {
        el.style.background = binding.value
      },
    })
  },
}
```

引入并使用自定义指令

```ts
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import changeColor from '@/directives/changeColor.ts' // 引入自定义指令

const app = createApp(App)

app.use(router)
app.use(changeColor) // 使用自定义指令

app.mount('#app')
```

## 定义全局函数和变量

### globalProperties

由于Vue3 没有Prototype 属性 使用 app.config.globalProperties 代替 然后去定义变量和函数

vue2：

```js
// 之前 (Vue 2.x)
Vue.prototype.$http = () => {}
```

vue3：

```ts
// 之后 (Vue 3.x)
const app = createApp({})
app.config.globalProperties.$http = () => {}
```

### 使用方法

在 main.ts 中定义全局变量和方法

```ts
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'
import '@/styles/index.scss'
import './permission.ts'

const app = createApp(App)

app.use(createPinia())
app.use(router)

// 声明 ts 类型
type Filter = {
  format<T>(str: string): string
}
declare module 'vue' {
  export interface ComponentCustomProperties {
    $filters: Filter
    $env: string
  }
}
// 定义全局变量
app.config.globalProperties.$env = 'dev'
// 定义全局方法
app.config.globalProperties.$filters = {
  format<T>(str: T) {
    return `小满-${str}`
  },
}

app.mount('#app')
```

使用全局变量和全局方法：

```vue
<template>
  <-- 在模板中使用全局变量和全局方法 !-->
  <div>{{ $env }}</div>
  <div>{{ $filters.format('的飞机') }}</div>
</template>

<script setup lang="ts">
import { getCurrentInstance } from 'vue'

// 在脚本中通过 getCurrentInstance 获取当前 app 实例，让然后通过 app.proxy 访问全局变量和全局方法
const app = getCurrentInstance()
console.log(app?.proxy?.$env)
console.log(app?.proxy?.$filters.format('ts'))
</script>
```

## 自定义 vue 插件

以创建一个 Loading 插件为例

1. 创建组件的 vue 文件和导出插件的安装文件

```vue
<template>
  <div class="loading">Loading...</div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const isShow = ref<boolean>(false)

const show = () => {
  isShow.value = true
}
const hide = () => {
  isShow.value = false
}

defineExpose({
  isShow,
  show,
  hide,
})
</script>

<style scoped>
.loading {
  width: 100%;
  height: 100vh;
  background-color: #7a7a7a;
  font-size: 50px;
  color: #fff;
  text-align: center;
  line-height: 100vh;
  user-select: none;
}
</style>
```

```ts
import { type App, type VNode } from 'vue'
import Loading from './index.vue'
import { createVNode, render } from 'vue'

export default {
  install(app: App) {
    // 通过 createVNode 函数将组件转成 VNode 的形式
    // 此时 VNode.component 还没有值
    const Vnode: VNode = createVNode(Loading)
    // 使用 render 函数将 VNode 挂载到页面上，render(Vnode, 挂载点)
    // 此时 VNode.component 有值
    render(Vnode, document.body)
    // 通过 VNode.component.exposed 可以查看到组件中抛出的变量和方法
    console.log(Vnode.component.exposed)
    // 通过 app.config.globalProperties 将组件挂载到全局（这里的挂载的名字不能和别的组件重名）
    app.config.globalProperties.$loading = {
      show: Vnode.component.exposed.show,
      hide: Vnode.component.exposed.hide,
    }
  }
}
```

2. 在 main.ts 中引入并注册插件

```ts
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import Loading from './component/Loading/index.ts' // 导入插件组件

const app = createApp(App)

app.use(router)
app.use(Loading) // 注册组件

app.mount('#app')
```

3. 在页面中使用插件

```vue
<template></template>

<script setup lang="ts">
import { getCurrentInstance } from 'vue'

const instance = getCurrentInstance() // 使用 getCurrentInstance 获取到当前的实例

instance.proxy?.$loading.show() // 用 instance 调用全局插件
setTimeout(() => {
  instance.proxy?.$loading.hide()
}, 3000)
</script>

<style scoped></style>
```

> 在 main.ts 声明类型文件（也可以写在 *.d.ts 文件中）

```ts
type Lod = {
  show: () => void
  hide: () => void
}
// 编写 ts loading 声明文件防止报错和智能提示
declare module '@vue/runtime-core' {
  export interface ComponentCustomProperties {
    $loading: Lod
  }
}
```

## nextTick

### 场景

发送聊天后，自动滚屏到最下方查看最新回复

```vue
<template>
  <div ref="box" class="wraps">
    <div>
      <div class="item" v-for="item in chatList">
        <div>{{ item.name }}：</div>
        <div>{{ item.message }}</div>
      </div>
    </div>
  </div>
  <div class="ipt">
    <div>
      <textarea v-model="ipt" type="text"></textarea>
    </div>
    <div>
      <button @click="send">发送</button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, nextTick } from 'vue'

let chatList = reactive([{ name: '张三', message: 'xxxxxxxxxxxxxxx' }])
let box = ref<HTMLDivElement>()
let ipt = ref('')
// vue 更新 dom 是异步的，数据更新是同步的
// 我们本次执行的代码是同步代码
// 当操作 dom 的时候，发现数据读取的是上次的，就需要使用 nextTick
const send = async () => {
  chatList.push({
    name: '小满',
    message: ipt.value,
  })
  // 1. 回调函数写法
  // nextTick(() => {
  //   box.value!.scrollTop = box.value!.scrollHeight
  // })
  // 2. async await 写法
  await nextTick()
  box.value!.scrollTop = box.value!.scrollHeight
}
</script>

<style scoped lang="scss">
.wraps {
  width: 500px;
  height: 400px;
  border: 1px solid #ccc;
  margin: 10px auto 0;
  overflow-y: auto;

  .item {
    display: flex;
    padding: 10px;
    background-color: #efefef;
    margin-bottom: 4px;
  }
}

.ipt {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  width: 500px;
  margin: 0 auto;

  textarea {
    width: 500px;
    height: 100px;
    margin-top: 20px;
  }
}
</style>
```