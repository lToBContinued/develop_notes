# vuex

## 概述

### vuex是什么？

vuex 是一个 vue 的`状态管理工具`，状态就是数据。
人话：vuex 是一个插件，可以帮我们`管理 vue 通用的数据（多组件共享的数据）`

### 场景

1. 某个状态 在`很多组件` 来使用（个人信息）
2. 多个组件 `共同维护` 一份数据（购物车）

### 优势

1. 共同维护一份数据，`数据集中化管理`
2. `响应式变化`
3. 操作简洁（vuex 提供了一些辅助函数）

## 创建一个空仓库

**目标：**安装vuex插件，初始化一个空仓库
`安装vuex → 新建vuex模块文件 → 创建仓库 → main.js导入挂载`

1. yarn add vuex@3
2. 新建 store/index.js 专门存放 vuex
3. Vue.use( Vuex )
   创建仓库 new Vuex.Store( )
4. 在 main.js 中导入挂载到 Vue 实例上

## 核心概念 - state 状态

### 使用步骤

1. 提供数据：
   State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。
   打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。

```js
const store = new Vuex.Store({
  // state 状态, 即数据, 类似于vue组件中的data,
  // 区别：
  // 1.data 是组件自己的数据,
  // 2.state 中的数据整个vue项目的组件都能访问到
  state: {
    count: 101,
  },
})
```

2. 使用数据：
   方法一：通过store直接访问

```js
获取
store：
 1.
Vue模板中获取
this.$store
2.
js文件中获取
import 导入 store

模板中：{{ $store.state.xxx }}
组件逻辑中：  this.$store.state.xxx
JS模块中：   store.state.xxx
```

​ 方法二：通过辅助函数（简化）
mapState是辅助函数，帮助我们把store中的数据`自动`映射到组件的计算属性中
`导入mapState → 数组方式引入state → 展开运算符映射`

```js
1.
import { mapStore } from 'vuex'
2.
mapStore(['count'])
3.
computed: {
...mapState(['count'])
}
```

## 核心概念 - mutations

vuex 同样遵循单项数据流，**组件中不能直接修改仓库中的数据**

### 基本使用

**使用步骤：**

1. 定义mutations对象，对象中存放修改state的方法

```js
const store = new Vuex.Store({
  state: {
    count: 100,
  },
  // 定义mutations
  mutations: {
    // 第一个参数是当前store的state属性
    addCount(state) {
      state.count += 1
    },
  },
})
```

2. 组件中提交调用mutations

```vue
<button @click="handleAdd">值 + 1</button>

<script>
export default {
  methods: {
    handleAdd() {
      // 提交调用mutations
      this.$store.commit('addCount')
    },
  },
}
</script>
```

### 传参方法

提供 mutation 是可以传递参数的 `this.$store.commit('xxx', 参数)`

1. 提供mutation函数（带参数（提交载荷payload））
   **注：**mutation中只能携带一个额外参数，如果想传递多个参数，用数组或者对象的形式

```js
mutations: {
...
  addCount(state, n)
  {
    state.count += n
  }
}
```

2. 页面中提交调用mutation

```vue
<button @click="handleAdd(1)">值 + 1</button>
<button @click="handleAdd(5)">值 + 5</button>
<button @click="handleAdd(10)">值 + 10</button>

<script>
export default {
  methods: {
    handleAdd(n) {
      this.$store.commit('addCount', n)
    },
  },
}
</script>
```

### 辅助函数：mapMutations

mapMutations 和 mapState 很像，它是把位于`mutations中的方法`提取了出来，映射到`组件methods`中

```js
mutations: {
  addCount(state, n)
  {
    state.count += n
  }
}
```

```vue
<button @click="addCount(1)">值 + 1</button>
<button @click="addCount(5)">值 + 5</button>
<button @click="addCount(10)">值 + 10</button>

<script>
import { mapMutations } from 'vuex'

methods: {
...
  mapMutations(['addCount'])
}
</script>
```

注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中

## 核心概念 - actions

> state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，
> actions则负责进行异步操作

### 使用步骤：

1. 提供action方法

```js
mutations: {
  changeCount(state, newCount)
  {
    state.count = newCount
  }
}

actions: {
  setAsyncCount(context, num)
  {
    // 一秒后, 给一个数, 去修改 num
    setTimeout(() => {
      // action 需要调用 mutations 中的方法来修改 state 中的数据
      context.commit('changeCount', num)
    }, 1000)
  }
}
```

2. 页面中 dispatch 调用

```vue
<button @click="handleChange(666)">一秒后修改成666</button>

<script>
export default {
  methods: {
    handleChange(num) {
      this.$store.dispatch('setAsyncCount', num)
    },
  },
}
</script>
```

### 辅助函数 - mapActions

mapActions 是把位于 `actions 中的方法` 提取了出来，映射到`组件methods`中

```js
actions: {
  changeCountAction(context, num)
  {
    setTimeout(() => {
      context.commit('changeCount', num)
    }, 1000)
  }
}
```

```vue
<script>
import { mapActions } from 'vuex'

export default {
  methods: {
    ...mapActions(['changeCountAction']),
  },
}
</script>
```

## 核心概念 - getters

> 除了state之外，有时我们还需要从state中`派生出一些状态`，这些状态是依赖state的，此时会用到getters
> 类似于计算属性

### 使用步骤

1. 定义getters

```js
getters: {
  // 注意：
  // （1）getters函数的第一个参数是 state
  // （2）getters函数必须要有返回值
  filterList(state)
  {
    return state.list.filter((item) => item > 5)
  }
}
```

2. 访问 getters

方法一：通过store访问getters

```vue
{{ $store.getters.filterList }}

this.$store.getters.filterList
```

​ 方法二：通过辅助函数 mapGetters 映射

```vue
{{ filterList }}

<script>
import { mapGetters } from 'vuex'

export default {
  computed: {
    ...mapGetters(['filterList']),
  },
}
</script>
```

## 核心概念 - 模块 module（进阶语法）

模块拆分：

例：user模块 store/modules/user.js

```js
// user.js
const state = {
  userInfo: {
    name: 'zs',
    age: 18,
  },
  score: 80,
}
const mutations = {}
const actions = {}
const getters = {}

export default {
  state,
  mutations,
  actions,
  getters,
}
```

导入使用

```js
// index.js
import user from './modules/user'
import setting from './modules/setting'

const store = new Vuex.Store({
  modules: {
    user,
    setting,
  },
})
```

### state 的访问语法

尽管已经分模块了，但其实子模块的状态，还是会挂到根级别的 state 中，属性名就是模块名
使用模块中的数据：

1. **方法一：**直接通过模块名访问 `$store.state.模块名.xxx`
2. **方法二：**通过 mapState 映射
   默认根级别的映射 `mapState(['xxx'])`
   子模块的映射 `mapState('模块名', ['xxx'])` - 需要开启命名空间

```js
// user.js
const state = {
  userInfo: {
    name: 'zs',
    age: 18,
  },
  score: 80,
}

export default {
  namespaced: true, // 开启命名空间
  state,
  mutations,
  actions,
  getters,
}
```

```vue
<div>{{ user.userInfo.name }}</div>
<div>{{ setting.theme }}</div>
<div>user模块的数据：{{ userInfo }}</div>
<div>setting模块的数据：{{ theme }} - {{ desc }}</div>

<script>
import { mapState } from 'vuex'

export default {
  computed: {
    // mapState 和 mapGetters 都是在映射属性
    ...mapState(['user', 'setting']),
    ...mapState('user', ['userInfo']),
    ...mapState('setting', ['theme', 'desc']),
  },
}
</script>
```

### getters 的访问语法

使用模块中 getters 中的数据：

1. **方法一：**直接通过模块名访问 `$store.getters['模块名/xxx']`

```vue
<div>{{ $store.getters['user/UpperCaseName'] }}</div>
```

2. **方法二：**通过 mapGetter 映射
   默认跟级别映射 `mapGetter(['xxx'])`
   子模块的映射 `mapGetter('模块名', ['xxx'])` - 需要开启命名空间

```js
// user.js
const getters = {
  // 分模块后，state指的是子模块的
  UpperCaseName(state) {
    return state.userInfo.name.toUpperCase()
  },
}

export default {
  namespaced: true,
  state,
  mutations,
  actions,
  getters,
}
```

```vue
<!--访问模块中的getters-->
<div>{{ UpperCaseName }}</div>

<script>
import { mapGetters } from 'vuex'

export default {
  computed: {
    ...mapGetters('user', ['UpperCaseName']),
  },
}
</script>
```

### mutation 的调用语法

> 注意：默认模块中的 mutation 和 actions 会被挂载到全局，`需要开启命名空间`，才会挂载到子模块

**调用子模块中 mutation：**

1. 通过 store 调用 `$store.commit('模块名/xxx', 额外参数)`

```js
// setting.js
const mutations = {
  setTheme(state, newColor) {
    state.theme = newColor
  },
}
```

```vue
<button @click="updateTheme">更新主题色</button>

<script>
export default {
  methods: {
    updateTheme() {
      this.$store.commit('setting/setTheme', 'pink')
    },
  },
}
</script>
```

2. 通过 mapMutations 映射：
   默认根级别的映射 `mapMutations(['xxx'])`
   子模块的映射 `mapMutations('模块名', ['xxx'])` - 需要开启命名空间

```vue
<button @click="setUser({ name: 'xiaoli', age: 80 })">更新个人信息</button>
<button @click="setTheme('skyblue')">更新主题</button>

<script>
import { mapMutations } from 'vuex'

export default {
  methods: {
    ...mapMutations('setting', ['setTheme']),
    ...mapMutations('user', ['setUser']),
  },
}
</script>
```

### actions 的调用语法

**调用子模块中的action：**

1. 直接通过 store 调用 `$store.dispatch('模块名/xxx', 额外参数)`

```js
// setting.js
const actions = {
  setTheme2(context, newColor) {
    setTimeout(() => {
      context.commit('setTheme', newColor)
    }, 1000)
  },
}

export default {
  namespaced: true,
  state,
  mutations,
  actions,
  getters,
}
```

```vue
<button @click="updateTheme2">一秒后更新主题色</button>

<script>
export default {
  methods: {
    updateTheme2() {
      this.$store.dispatch('setting/setTheme2', 'red')
    },
  },
}
</script>
```

2. 通过 mapActions 映射
   默认根级别的映射 `mapActions(['xxx])`
   子模块的映射 `mapActions('模块名', ['xxx'])`

```vue
<button @click="setUserSecond({ name: '小王', age: 25 })">一秒后更新个人信息</button>

<script>
import { mapActions } from 'vuex'

export default {
  methods: {
    ...mapActions('user', ['setUserSecond']),
  },
}
</script>
```
