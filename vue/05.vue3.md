# vue3

## 使用create-vue创建项目

1. 前提环境条件：`已安装16.0或更高版本的node.js`
2. 创建一个vue应用：`npm init vue@latest`（这一行指令会安装并执行create-vue）

# 组合式API

## 组合式API - setup

**特点：**

1. 执行时机比 beforeCreated 还要早
2. setup 函数中获取不到 this，this 是 undefined（因为 setup 函数创建的时机比 beforeCreated 还要早）
3. 在 setup 中写的任何数据和函数必须 return，才能在模版中使用

```vue
<script>
export default {
  setup() {
    // 数据
    const message = 'this is message'
    // 函数
    const logMessage = () => {
      console.log(message)
    }
    return {
      message,
      logMessage,
    }
  },
}
</script>

<template>
  <!--使用方法和数据-->
  {{ message }}
  <button @click="logMessage">logMessage</button>
</template>
```

4.通过 `<script setup>` 语法糖简化代码

```vue
// 原始复杂写法
<script>
export default {
  setup() {
    // 数据
    const message = 'this is message'
    // 函数
    const logMessage = () => {
      console.log(message)
    }
    return {
      message,
      logMessage,
    }
  },
}
</script>

// 语法糖写法
<script setup>
// 数据
const message = 'this is message'
// 函数
const logMessage = () => {
  console.log(message)
}
</script>
```

## 组合式 API - reactive 和 ref 函数

### reactive( )

#### 作用

接收`对象类型数据的参数传入`并返回一个`响应式对象`

#### 核心步骤

1. 从 vue 包中导入`reactive`函数
2. 在 <script setup>中`执行 reactive 函数`并传入`类型为对象`的初始值，并使用变量接收返回值

```vue
<script setup>
// 导入
import { reactive } from 'vue'

// 执行函数 传入参数 变量接收
const state = reactive(对象类型数据)
</script>
```

### ref( )

#### 作用

接收`简单类型或者对象类型的数据`传入并返回一个`响应式的对象`

#### 核心步骤

1. 从 vue 包中导入`ref`函数
2. 在 <script setup>中`执行 ref 函数`并传入初始值，使用`变量接收`ref函数的返回值

```vue
<script setup>
// 导入
import { ref } from 'vue'

// 执行函数 传入参数 变量接收
const count = ref(简单类型或者复杂类型数据)
</script>
```

#### 本质

是在原有传入数据的基础上，外层包了一层对象（即使是传入的数组和对象也会再被包一层对象），包成了复杂类型
**底层，**包成复杂类型之后，再借助 reactive 实现的响应式
**注意点：**

1. `脚本中`访问数据，需要通过 .value
2. 在 `template 中`，.value不需要写（帮我们扒了一层）

```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)
// 脚本中访问数据，需要通过 .value
console.log(count.value)
const setCount = () => {
  count.value++
}
</script>

<template>
  <div>
    <!--在 template 中，.value不需要写-->
    <div>{{ count }}</div>
    <button @click="setCount">+1</button>
  </div>
</template>
```

### 推荐

以后声明数据，统一用 ref → 统一了编码规范

## 组合式API - computed

计算属性基本思想和 vue2 的完全一致，组合式API下的计算属性`只是修改了写法`

### 核心步骤

1. `导入` computed 函数
2. `执行函数`在回调参数中 `return 基于响应式数据做计算的值`，用`变量接收`

```vue
<script setup>
// 导入
import { computed } from 'vue'

// 执行函数 变量接收 在毁掉参数中return计算值
const computedState = computed(() => {
  return 基于响应式数据做计算后的值
})
</script>
```

完整写法：

```vue
<script>
import { ref, computed } from 'vue'

const count = ref(1)
const changeCount = computed({
  get: () => {
    return count.value + 1
  },
  set: (val) => {
    return (count.value = val - 1)
  },
})
changeCount.value = 5
console.log(count.value) // 4
</script>
```

**注意：**

1. 计算属性中不应该有“副作用”
   `比如异步请求/修改dom`
2. 避免直接修改计算属性的值
   `计算属性应该是只读的，特殊情况可以配置get set`

## 组合式API - watch

**作用：**侦听一个或者多个数据的变化，数据变化时执行回调函数
**两个额外参数：**1. immediate（立即执行） 2. deep（深度监听）

### 基础使用 - 侦听单个数据

1. `导入 watch` 函数
2. `执行 watch 函数`传入要侦听的响应式数据`（ref 对象）`和回调函数

```vue
<script setup>
// 1.导入watch
import { ref, watch } from 'vue'

const count = ref(1)

// 2.调用watch侦听变化
watch(count, (newValue, oldValue) => {
  console.log(`count发生了变化，老值为${oldValue}，新值为${newValue}`)
})
</script>
```

### 基础使用 - 侦听多个数据

```vue
<script setup>
// 1.导入watch
import { ref, watch } from 'vue'

const count = ref(1)
const name = ref('cp')

// 2.调用watch侦听变化
watch(
  // 将需要监听的数据作为数组传入
  [count, name],
  ([newCount, newName], [oldCount, oldVName]) => {
    console.log('count或者name发生了变化', [newCount, newName], [oldCount, oldVName])
  },
)
</script>
```

### immediate

**作用：**在侦听器创建时`立即触发回调`，响应式数据变化之后继续执行回调

```vue
<script setup>
watch(
  count,
  (newValue, oldValue) => {
    console.log(newValue, oldValue)
  },
  {
    immediate: true,
  },
)
</script>
```

### deep

deep 深度监视，默认 watch 进行的是浅层监视
const ref1 = ref(简单类型) 可以直接监视
const ref2 = ref(复杂类型) 监视不到复杂类型内部的数据变化

```vue
<script setup>
import { ref, watch } from 'vue'

const userInfo = ref({
  name: 'zs',
  age: 18,
})

const setUserInfo = () => {
  userInfo.value.age++
}

watch(
  userInfo,
  (newValue) => {
    console.log(newValue)
  },
  {
    deep: true,
  },
)
</script>
```

### 精确侦听对象的某个属性

需求：在不开启 deep 的情况下，侦听 age 的变化，只有 age 变化时才执行回调

```vue
<script setup>
import { ref, watch } from 'vue'

const userInfo = ref({
  name: 'zs',
  age: 18,
})

const setUserInfo = () => {
  userInfo.value.age++
  // userInfo.value.name = 'ls'
}

// 把第一个参数写成函数的写法，返回要监听的具体属性值
watch(
  () => userInfo.value.age,
  (newValue, oldValue) => {
    console.log(newValue, oldValue)
  },
)
</script>
```

## 组合式API - vue3的生命周期

|        选项式API        |     组合式API     |
| :---------------------: | :---------------: |
| `beforeCreated/created` |      `setup`      |
|       beforeMount       |   onBeforeMount   |
|         mounted         |     onMounted     |
|      beforeUpdate       |  onBeforeUpdate   |
|         updated         |     onUpdated     |
|     `beforeUnmount`     | `onBeforeUnmount` |
|       `unmounted`       |   `onUnmounted`   |

```vue
<script setup>
import { onMounted } from 'vue'

// beforeCreate 和 created 的相关代码一律放在 setup 中执行
const getList = () => {
  setTimeout(() => {
    console.log('发送请求，获取数据')
  }, 2000)
}
// 因为 setup 执行时机比 beforeCreated 还要早，而<script setup>是setup的语法糖简化代码，因此一进页面的请求可以直接写
getList()

// 如果有些代码需要在 mounted 生命周期中执行
onMounted(() => {
  console.log('mounted生命周期函数 - 逻辑1')
})

// 写成函数的调用方式，可以调用多次，并不会冲突，而是按照顺序依次执行
onMounted(() => {
  console.log('mounted生命周期函数 - 逻辑2')
})
</script>
```

## 组合式API下的父子通信

### 父传子

**基本思想：**

1. 父组件中给`子组件以绑定属性的方式传值`
2. 子组件内部通过`props选项接收`

```vue
<!--App.vue 父组件-->
<script setup>
// 引入子组件
import sonComVue from './son-com.vue'
</script>

<template>
  <!--1.绑定属性 message-->
  <sonComVue message="this is app message"></sonComVue>
</template>
===========================================================================================
<!--som-com.vue 子组件-->
<script setup>
// 2.通过defineProps "编译器宏"接收子组件传递的数据
const props = defineProps({
  message: String,
})
</script>

<template>
  {{ message }}
</template>
```

defineProps原理：就是编译阶段的一个表示，实际编辑器解析时，遇到后会进行编译转换

### 子传父

**基本思想：**

1. 父组件中给`子组件标签用过 @ 绑定事件`
2. 子组件内部通过 `emit 方法触发事件`

```vue
<!--App.vue 父组件-->
<script setup>
// 引入子组件
import sonComVue from './son-com.vue'

const getMessage = (msg) => {
  console.log(msg)
}
</script>

<template>
  <!--1.绑定自定义事件-->
  <sonComVue @get-message="getMessage"></sonComVue>
</template>
===========================================================================================
<!--son-com.vue 子组件-->
<script setup>
// 2.通过 defineEmits 编译器宏生成 emit 方法，任何在 emit 中触发的方法都需要在 defineEmits 中声明
const emit = defineEmits(['get-message'])

const sendMsg = () => {
  // 3.触发自定义事件 并传递参数
  emit('get-message', 'this is a message')
}
</script>

<template>
  <button @click="sendMsg">sendMsg</button>
</template>
```

## 组合式API - 模板引用

**模板引用的概念：**通过`ref标识`获取真实的`dom对象或者组件实例对象`

### 核心步骤

1. 调用 ref 函数生成一个 ref 对象
2. 通过 ref 标识绑定 ref 对象到标签

```vue
<script setup>
import TestCom from '@/components/test-com.vue'
import { onMounted, ref } from 'vue'

// 模版引用（可以获取dom，也可以获取组件）
// 获取 dom
// 1.调用ref函数生成ref对象
const inp = ref(null)

// 3.通过ref对象，value即可访问绑定的元素（必须渲染完成后，才能拿到）
// 生命周期钩子 onMounted，等 dom 渲染完
onMounted(() => {
  console.log(inp.value)
  inp.value.focus()
})

const clickFn = () => {
  inp.value.focus()
}
// -------------------------------
// 获取组件
const testRef = ref(null)

const getCom = () => {
  console.log(testRef.value)
}
</script>

<template>
  <div>
    <!--2.通过ref标识进行绑定-->
    <input ref="inp" type="text" />
    <button @click="clickFn">点击让输入框聚焦</button>
  </div>
  <TestCom ref="testRef"></TestCom>
  <button @click="getCom">获取组件</button>
</template>
===========================================================================================
<!--test-com.vue 组件-->
<script setup>
const count = 999
const sayHi = () => {
  console.log('打招呼')
}
</script>

<template>
  <div>我是用于测试的组件 - {{ count }}</div>
</template>
```

### defineExpose( )

默认情况下在 <script setup> 语法糖下`组件内部的属性和方法是不开放`给父组件访问的，可以通过 defineExpose 编译宏`指定哪些属性和方法允许访问`

```vue
<script setup>
import TestCom from '@/components/test-com.vue'
import { onMounted, ref } from 'vue'

// 生成 ref 对象
const testRef = ref(null)

const getCom = () => {
  // 获取子组件中暴露出来的数据和使用的函数
  console.log(testRef.value.count) // 999
  testRef.value.sayHi() // 打招呼
}
</script>

<template>
  <TestCom ref="testRef"></TestCom>
  <button @click="getCom">获取组件</button>
</template>
===========================================================================================
<!--test-com.vue 组件-->
<script setup>
const count = 999
const sayHi = () => {
  console.log('打招呼')
}
defineExpose({
  count,
  sayHi,
})
</script>

<template>
  <div>我是用于测试的组件 - {{ count }}</div>
</template>
```

## 组合式API - provide和inject

### 作用和场景

顶层组件向任意的底层组件`传递数据和方法`，实现`跨层组件通信`

### 跨层传递普通数据

1. 顶层组件通过 `provide 函数提供`数据
2. 底层组件通过 `inject 函数获取`数据

```vue
<!--顶层组件-->
<script setup>
import CenterCom from '@/components/center-com.vue'
import { provide, ref } from 'vue'

// 1.跨层传递普通数据
provide('theme-color', 'pink')

// 2.跨层传递响应式数据
const count = ref(100)
provide('count', count)

setTimeout(() => {
  count.value = 500
}, 2000)

// 3.跨层级传递函数 => 给子孙后代传递可以修改数据的方法
provide('changeCount', (newValue) => {
  count.value = newValue
})
</script>

<template>
  <div>
    <h1>我是顶层组件</h1>
    <CenterCom></CenterCom>
  </div>
</template>
===========================================================================================
<!--中间组件-->
<script setup>
import BottomCom from '@/components/bottom-com.vue'
</script>

<template>
  <div>
    <h2>我是中间组件</h2>
    <BottomCom></BottomCom>
  </div>
</template>
===========================================================================================
<!--底层组件-->
<script setup>
import { inject } from 'vue'

// 获取顶层组件传递过来的数据
const themeColor = inject('theme-color')
const count = inject('count')
const changeCount = inject('changeCount')
// 底层组件只能通过顶层组件传递过来的函数来修改顶层组件的数据，本质还是顶层组件修改自己的数据
const clickFn = () => {
  changeCount(1000)
}
</script>

<template>
  <div>
    <h3>我是底层组件 - {{ themeColor }} - {{ count }}</h3>
    <button @click="clickFn">更新count</button>
  </div>
</template>
```

# Vue3.3新特性

## defineOptions

### 背景说明：

有 <script setup> 之前，如果要定义 props, emits 可以轻而易举地添加一个与 setup 平级的属性。
但是用了 <script setup> 后，就没法这么干了 setup 属性已经没有了，自然无法添加与其平级的属性。

---

为了解决这一问题，引入了 defineProps 与 defineEmits 这两个宏。但这只解决了 props 与 emits 这两个属性。
如果我们要定义组件的 name 或其他自定义的属性，还是得回到最原始的用法——再添加一个普通的 <script> 标签。
这样就会存在两个 <script> 标签。让人无法接受。

---

所以在 Vue 3.3 中新引入了 defineOptions 宏。顾名思义，主要是用来定义 Options API 的选项。可以用 defineOptions 定义任意的选项， props, emits, expose, slots 除外（因为这些可以使用 defineXXX 来做到）

```vue
<script setup>
defineOptions({
  name: 'loginIndex',
  inheritAttrs: false,
  // ...更多自定义属性
})
</script>
```

## defineModel

在Vue3中，自定义组件上使用v-model, 相当于传递一个modelValue属性，同时触发 update:modelValue 事件

```vue
<child v-model="isVisible"></child>
// 相当于
<child :modelValue="isVisible" @update:modelValue="isVisible = $event"></child>
```

我们需要先定义 props，再定义 emits 。其中有许多重复的代码。如果需要修改此值，还需要手动调用 emit 函数。于是 defineModel 诞生了。

### 实现父和子的双向绑定

```vue
<!--App.vue 父组件-->
<script setup>
import MyInput from '@/components/my-input.vue'
import { ref } from 'vue'

const txt = ref('123456')
</script>

<template>
  <div>
    <MyInput v-model="txt"></MyInput>
    {{ txt }}
  </div>
</template>
===========================================================================================
<!--my-input 子组件-->
<script setup>
import { defineModel } from 'vue'

const modelValue = defineModel()
</script>

<template>
  <input type="text" :value="modelValue" @input="(e) => (modelValue = e.target.value)" />
</template>
```

# Pinia 快速入门

## 什么是Pinia

Pinia 是 Vue 的最新`状态管理工具`，是 Vuex 的`替代品`

1. 提供更简单的 API （去掉 mutation）
2. 提供符合组合式风格的 API（和 Vue3 新语法统一）
3. 去掉了 modules 的概念，每一个 store 都是一个独立的模块
4. 配合 TypeScript 更加友好，提供可靠的类型判断

## 手动添加 Pinia 到 Vue 项目

在实际开发项目的时候，关于 Pinia 的配置，可以在项目创建时自动添加

1. 使用 Vite 创建一个空的 Vue3 项目
   npm create vue@latest
2. `按照官方文档`安装 pinia 到项目中

```js
// main.js
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
const pinia = createPinia() // 创建pinia实例
const app = createApp(App) // 创建根实例
app.use(pinia) // pinia 插件安装配置
app.mount('#app') // 视图的挂载
```

## 定义 store

Store 使用 defineStore( ) 定义的，它的第一个参数要求是一个**独一无二的**名字

```vue
<script setup>
import { defineStore } from 'pinia'

// 你可以任意命名 `defineStore()` 的返回值，但最好使用 store 的名字，同时以 `use` 开头且以 `Store` 结尾。
// (比如 `useUserStore`，`useCartStore`，`useProductStore`)
// 第一个参数是你的应用中 Store 的唯一 ID。
export const useAlertsStore = defineStore('alerts', {
  // 其他配置...
})
</script>
```

例：

```js
// store/counter.js

import { defineStore } from 'pinia'
import { ref } from 'vue'

// 定义store
// defineStore('仓库的唯一标识',()=>{ ... })
export const useCountStore = defineStore('counter', () => {
  // useCountStore 是一个函数，在别的组件中需要以函数调用的方式使用
  // 声明数据 state - count
  const count = ref(100)

  // 可以声明不止一个数据 state - msg
  const msg = ref('hello pinia')

  // 暴露出count和msg
  return {
    count,
    msg,
  }
})
```

```vue
<!--App.vue-->

<script setup>
// 导入store
import { useCountStore } from '@/store/counter'

// 以使用函数的形式使用store，在组件中的使用方式也是一样
const counterStore = useCountStore()
console.log(counterStore)
</script>

<template>
  <div>
    <h3>根组件 - {{ counterStore.count }} - {{ counterStore.msg }}</h3>
  </div>
</template>
```

## action 和 computed 的基本语法

### action 同步实现

```js
// store/counter.js

import { defineStore } from 'pinia'
import { ref } from 'vue'

export const useCountStore = defineStore('counter', () => {
  const count = ref(100)

  // 声明操作数据的方法 action（普通函数就是action）
  const addCount = () => {
    count.value++
  }
  const subCount = () => {
    count.value--
  }

  const msg = ref('hello pinia')

  // 向外暴露store中的内容
  return {
    count,
    addCount,
    subCount,
    msg,
  }
})
```

```vue
<!--son1Com.vue-->
<script setup>
import { useCountStore } from '@/store/counter'
const counterStore = useCountStore()
</script>

<template>
  <div>
    我是son1 - {{ counterStore.count }} -
    <!--调用action中的方法-->
    <button @click="counterStore.addCount()">+</button>
  </div>
</template>
===========================================================================================
<!--son2Com-->
<script setup>
import { useCountStore } from '@/store/counter'
const counterStore = useCountStore()
</script>

<template>
  <div>
    我是son2 - {{ counterStore.count }} -
    <!--调用action中的方法-->
    <button @click="counterStore.subCount()">-</button>
  </div>
</template>
===========================================================================================
<!--App.vue-->
<script setup>
import Son1Com from '@/components/son1Com.vue'
import Son2Com from '@/components/son2Com.vue'
import { useCountStore } from '@/store/counter'

const counterStore = useCountStore()
console.log(counterStore)
</script>

<template>
  <div>
    <h3>根组件 - {{ counterStore.count }} - {{ counterStore.msg }}</h3>
    <Son1Com></Son1Com>
    <Son2Com></Son2Com>
  </div>
</template>
```

### getters

```js
import { defineStore } from 'pinia'
import { computed, ref } from 'vue'

export const useCountStore = defineStore('counter', () => {
  const count = ref(100)

  // 声明基于数据派生的计算属性 getters（computed）
  const double = computed(() => {
    return count.value * 2
  })

  return {
    count,
    double,
    msg,
  }
})
```

```vue
<!--son1Com.vue-->
<script setup>
import { useCountStore } from '@/store/counter'

const counterStore = useCountStore()
</script>

<template>
  <!--使用计算属性-->
  <div>
    我是son1 - {{ counterStore.double }}
    <button @click="counterStore.addCount()">+</button>
  </div>
</template>
```

### action 异步实现

#### 编写方式：

异步 action 函数的写法和`组件中获取异步数据的写法完全一致`
例：

```js
// store/channel.js

import { defineStore } from 'pinia'
import { ref } from 'vue'
import axios from 'axios'

export const useChannelStore = defineStore('channel', () => {
  // 声明数据
  const channelList = ref([])
  // 声明操作数据的方法
  const getList = async () => {
    // 支持异步
    const {
      data: { data },
    } = await axios({
      url: 'http://geek.itheima.net/v1_0/channels',
    })
    channelList.value = data.channels
    console.log(data.channels)
  }

  return {
    channelList,
    getList,
  }
})
```

```vue
<!--App.vue-->
<script setup>
import { useChannelStore } from '@/store/channel'
const channelStore = useChannelStore()
</script>

<template>
  <div>
    <!--获取频道数据-->
    <button @click="channelStore.getList">获取频道数据</button>
    <ul>
      <!--渲染频道列表-->
      <li v-for="item in channelStore.channelList" :key="item.id">{{ item.name }}</li>
    </ul>
  </div>
</template>
```

## storeToRefs 方法

**场景：**在组件中直接解构 store 中拿过来的数据，不处理，数据会丢失响应式
例：

```js
import { defineStore } from 'pinia'
import { computed, ref } from 'vue'

export const useCountStore = defineStore('counter', () => {
  const count = ref(100)

  const addCount = () => {
    count.value++
  }
  const subCount = () => {
    count.value--
  }

  const double = computed(() => {
    return count.value * 2
  })

  const msg = ref('hello pinia')

  return {
    count,
    double,
    addCount,
    subCount,
    msg,
  }
})
```

```vue
<!--App.vue-->
<script setup>
import Son1Com from '@/components/son1Com.vue'
import Son2Com from '@/components/son2Com.vue'
import { useCountStore } from '@/store/counter'
const counterStore = useCountStore()

// 此时，直接解构，不处理，数据会丢失响应式
const { count, msg } = counterStore
</script>

<template>
  <div>
    <h3>
      根组件
      <!--直接使用结构后的数据，不是响应式的-->
      - {{ count }} - {{ msg }}
    </h3>
    <Son1Com></Son1Com>
    <Son2Com></Son2Com>
  </div>
</template>
===========================================================================================
<!--son1Com-->
<script setup>
import { useCountStore } from '@/store/counter'

const counterStore = useCountStore()
</script>

<template>
  <div>
    我是son1 - {{ counterStore.count }} - {{ counterStore.double }}
    <button @click="counterStore.addCount()">+</button>
  </div>
</template>
===========================================================================================
<!--son2Com-->
<script setup>
import { useCountStore } from '@/store/counter'
const counterStore = useCountStore()
</script>

<template>
  <div>我是son2 - {{ counterStore.count }} - <button @click="counterStore.subCount()">-</button></div>
</template>
```

**解决方法：**

```vue
<!--App.vue-->
<script setup>
import { storeToRefs } from 'pinia'
// ...其它代码
// 使用 storeToRefs(对象) 解构
const { count, msg } = storeToRefs(counterStore)
// 如果是action方法的话，可以直接从store中解构
const { addCount, subCount } = counterStore
</script>
```

## Pinia 持久化插件

官方文档：https://prazdevs.github.io/pinia-plugin-persistedstate/zh/

### 使用步骤

1. 安装依赖
   pnpm：pnpm i pinia-plugin-persistedstate
   npm：npm i pinia-plugin-persistedstate
   yarn：yarn add pinia-plugin-persistedstate
2. 将插件添加到 pinia 实例上

```js
// main.js
import { createApp } from 'vue'
import { createPinia } from 'pinia'
// 导入持久化插件
import persist from 'pinia-plugin-persistedstate'

const pinia = createPinia()
const app = createApp(App)
app.use(pinia.use(persist))
```

3. 在 store 中开启持久化

```js
// store.js
// 在 store 的第三个参数位置添加开启持久化代码
export const useCountStore = defineStore(
  'counter',
  () => {
    // ... 其他代码
  },
  {
    // 开启持久化
    persist: true,
  },
)
```

更多配置，例如：修改本地存储的唯一标识、指定哪些数据需要被持久化等可以看官网中的配置选项。

```js
// store.js
export const useCountStore = defineStore(
  'counter',
  () => {
    const count = ref(100)
    const msg = ref('hello pinia')
    // ... 其他代码
  },
  {
    persist: {
      key: 'hm-counter', // 修改本地存储的唯一标识
      paths: ['count'], // 存储的是哪些数据
    },
  },
)
```

# vue-router4 路由代码解析

## 路由初始化

1. 创建路由实例由 createRouter 实现
2. 路由模式
   2.1 history 模式使用 `createWebHistory( )`
   2.2 hash 模式使用 `createWebHashHistory( )`
   2.3 参数是`基础路径`，默认/

```js
import { createRouter, createWebHistory } from 'vue-router'
// 初始化 vue-router4.x(Vue3)
const router = createRouter({
  // vite 中的环境变量 import.meta.env.BASE_URL 就是 vite.config.js 中的 base 配置项
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [],
})

export default router
```

## 获取路由对象和参数

1. 获取路由对象 router → useRouter
   `const router = useRouter( )`
2. 获取路由参数route → useRoute
   `const route = useRoute( )`

```vue
<script setup>
// 在vue3 compositionAPI中
// 1. 获取路由对象 router useRouter
//    const router = useRouter()
// 2. 获取路由参数router useRoute
//    const route = useRoute()
import { useRoute, useRouter } from 'vue-router'

const router = useRouter()
const route = useRoute()

const goList = () => {
  console.log(router, route)
  router.push('/list')
}
</script>

<template>
  <div>
    <button @click="$router.push('/home')">跳首页</button>
    <button @click="goList">跳列表页</button>
  </div>
</template>
```
