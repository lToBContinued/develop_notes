# VueRouter - 路由

## VueRouter的使用 (5 + 2)

### 5个基础步骤（固定）

1. 下载：下载VueRouter模块到当前工程，版本3.6.5

```
yarn add vue-router@3.6.5
```

2. 引入

```js
import VueRouter from 'vue-router'
```

3. 安装注册

```js
Vue.use(VueRouter)
```

4. 创建路由对象

```js
const router = new VueRouter()
```

5. 注入，将路由对象注入到new Vue实例中，建立关联

```js
new Vue({
  render: (h) => h(App),
  router,
}).$mount('#app')
```

### 2个核心步骤

1. 创建需要的组件（views目录），配置路由规则

```js
// 例：搭建一个音乐应用页面（发现、我的、朋友）
import Find from './views/Find.vue'
import My from './views/My.vue'
import Friend from './views/Friend.vue'

const router = new VueRouter({
  routes: [
    { path: '/find', components: Find },
    { path: '/my', components: My },
    { path: '/friend', components: Friend },
  ],
})
```

2. 配置导航，配置路由出口（路径匹配的组件显示的位置）

```vue
<div class="footer_wrap">
  <a href="#/find">发现音乐</a>
  <a href="#/my">我的音乐</a>
  <a href="#/friend">朋友</a>
</div>
<div class="top">
  <!-- 路由出口 -> 匹配的组件所展示的位置 -->
  <router-view></router-view>
</div>
```

## 组件存放目录问题

**组件分类：**.vue文件分为2类，页面组件&复用组件
分类开来 `更易维护`

1. src/views文件夹：**页面组件**-页面展示-配合路由使用
2. src/components文件夹：**复用组件**-展示数据-常用于反复使用

## 路由的封装抽离

**问题：**所有的路由配置都堆在main.js中合适吗？
**目标：**将路由模块抽离出来。
**好处：**拆分模块，利于维护
**步骤：**

1. 新建文件夹router和router下的index.js文件
2. 将所有的路由代码挪到index.js中

```js
// index.js文件
// 导入其他的组件
import Home from '@/views/Home'   // “@”代表src文件夹
import Search from '@/views/Search'

// 导入Vue，因为Vue.use(VueRouter)中要用到Vue
import Vue from 'vue'

// 导入路由插件
import VueRouter from 'vue-router'

Vue.use(VueRouter) // VueRouter插件初始化

// 创建了一个路由对象
const router = new VueRouter({
  routes: [
    { path: '/home', component: Home },
    { path: '/search', component: Search }
  ]
})

// 导出 router, 之后在 main.js 导入使用
export default router


// main.js文件
import router from 'index.js文件所在路径'

new Vue({
  render: h => h(App),
  router
}).$mount('#app')
```

## router-link

### router-link 标签

`router-link`提供了一个全局组件 **<router-link>** (取代a标签)

1. `能跳转`，匹配to属性指定路径（**必须**）。本质还是a标签，**to无需#**
2. `能高亮`，默认就会提供**高亮类名**，可以直接设置高亮样式
   例：

```vue
<template>
  <div>
    <div class="footer_wrap">
      <router-link to="/find">发现音乐</router-link>
      <router-link to="/my">我的音乐</router-link>
      <router-link to="/friend">朋友</router-link>
    </div>
    <div class="top">
      <!-- 路由出口 → 匹配的组件所展示的位置 -->
      <router-view></router-view>
    </div>
  </div>
</template>

<style>
.footer_wrap a.router-link-active {
  background-color: purple;
}
</style>
```

### 两个类名（精确匹配和模糊匹配）

**router-link-active、router-link-exact-active**

1. router-link-active `模糊匹配（用的多）`
   to="/my" 可以匹配 /my、/my/a、/my/b
2. router-link-exact-active `精确匹配`
   to="/my" 仅可以匹配 /my

## 声明式导航 - 跳转传参

### 查询参数传参

**语法：**

1. to="/path`?参数名=值`"（如果后面还有多个参数，通过**&**分割，然后再写**参数名=值**）
2. 对应页面组件接收传递过来的值：$route.`query.参数名`

### 动态路由传参

**语法：**

1. 配置动态路由

```js
const router = new VueRouter({
  routes: [
    ...其他配置,
    {
      path: '/search/:参数名',
      component: Search,
    },
  ],
})
```

2. 配置导航链接：to="/path`/参数值`"

```vue
<router-link to="/search/参数值">黑马程序员</router-link>
```

3. 对应页面组件接收传递过来的值：$route.`params.参数名`

```vue
<p>这样就会把to中配置的参数值传过来: {{ $route.params.参数名 }}</p>
```

### 两种传参方式的区别

1. 查询参数传参（比较适合传**多个参数**）
   路由中不需要额外配置
   ① 跳转：to="path/search`?参数名1=参数值&参数名2=参数值`"
   ② 获取：$route.query.`参数名`

2. 动态路由传参（优雅简洁，传**单个参数**比较方便）
   ① 配置动态路由：path:"/path/`:参数名`"
   ② 跳转：to="/path/`参数值`"
   ③ 获取：$route.params.`参数名`

### 动态路由参数可选符

/search/:words表示，必须要传参数。如果不传参数，也希望匹配，可以加可选符"`?`"

```js
const router = new VueRouter({
  routes: [
    ...其他配置,
    {
      path: '/search/:参数名?',
      component: Search,
    },
  ],
})
```

## Vue路由

### 重定向

**问题：**网页打开，url默认是/路径，未匹配到组件时，会出现空白页
**说明：**重定向 → 匹配path后，强制跳转path路径
**语法：**{ path: 匹配路径, redirect: 重定向到的路径 }
例：

```js
const router = new VueRouter({
  routes: [
    { path: '/', redirect: '/home' }, // 效果：当我们访问“/”这个地址页面的时候，直接自动跳转到home页面
    { path: '/home', component: Home },
    { path: '/search/:words?', component: Search },
  ],
})
```

### 404

**作用：**当路径找不到匹配时，给个页面提示
**位置：**配在`路由最后`
**语法：**path:"\*"（任意路径） - 前面都不匹配就命中最后这个
例：

```js
const router = new VueRouter({
  routes: [
    { path: '/', redirect: '/home' },
    { path: '/home', component: Home },
    { path: '/search/:words?', component: Search },
    { path: '*', component: NotFound }, // 当前面的页面都找不到时，显示NotFound页面
  ],
})
```

### 模式设置

**问题：**路由的路径看起来不自然，有“`#`”，能否切换成真正的路径形式？
hash路由（默认） 例如：http://localhost:8080/#/home
history路由（常用） 例如：http://localhost:8080/home（以后上线需要服务端支持）
**方法：**在路由当中，额外的配置模式

```js
const router = new VueRouter({
  routes,
  mode: 'history', // 一旦切换成了history模式，地址栏就没有#了，需要后台配置访问规则
})
```

## 编程式导航

### 基本跳转

**编程式导航：**用 js 代码来进行跳转
**两种语法：**

1. path 路径跳转（简易方便）

```vue
// （简写）： this.$router.push('路由路径') // （完整写法，后面传参要用到）： this.$router.push({ path: '路由路径' })
```

2. name 命名路由跳转（适合 path 路径长的场景）

```js
{
  name: '路由名',
  path: '/path/xxx',
  component: xxx
}
```

```vue
this.$router.push({ name: '路由名' })
```

### 路由传参

两种传参方式：查询路径 + 动态路由传参
两种跳转方式，对于两种传参方式都支持：

#### path 路径跳转传参：

1. query 传参：

```vue
// 简写： this.$router.push('/路径?参数名1=参数值&参数名2=参数值') // 完整写法： this.$router.push({ path: '/路径',
query: { 参数名1:参数值 参数名2:参数值 } })
```

2. 动态路由传参

```vue
// 简写： this.$router.push('/路径/参数值') // 完整写法： this.$router.push({ path: '/路径/参数值' })
```

#### name 命名路由跳转传参：

1. query 传参

```vue
this.$router.path({ name: '路由名', query: { 参数名1: 参数值, 参数名2: 参数值 } })
```

2. 动态路由传参

```vue
this.$router.path({ name: '路由名', params: { // 参数名要和js中配置路由的动态参数名一致 参数名: 参数值 } })
```

## 组件缓存 keep-alive

**问题：**从其他 页面1 跳转到 页面2，又返回，数据重新加载了 -> 我希望回到原来的位置
**原因：**路由跳转后，组件被销毁了，返回回来组件有被重建了，所以数据重新被加载了
**解决：**利用 keep-alive 将组件缓存下来

### keep-alive是什么？

keep-alive是Vue的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。
keep-alive是一个抽象组件：它自身不会渲染成一个DOM元素，也不会出现在父组件链接中。

### keep-alive的优点

1. 在组件切换过程中，把切出去的组件保留在内存中，防止重复渲染DOM
2. 减少加载时间及性能消耗，提高用户体验
   例：

```vue
<template>
  <div class="h5-wrapper">
    <!--使用keep-alive缓存组件-->
    <!--被keep-alive包裹的所有一级组件都会被缓存-->
    <keep-alive>
      <router-view></router-view>
      <!--被缓存的组件-->
    </keep-alive>
  </div>
</template>
```

如果router-view路由中有多个组件，但是有的不想被缓存？↓

### keep-alive的三个属性

`1. include: 组件名数组，只有匹配的组件会被缓存（用的比较多）`

2. exclude: 组件名数组，任何匹配的组件都不会被缓存（通常配合max一起使用）
3. max: 最多可以缓存多少组件实例
   例：

```vue
<template>
  <div class="h5-wrapper">
    <!--包裹了keep-alive，所有的一级路由匹配的组件（Layout和Detail）都会被缓存-->
    <!--需求：只需要Layout被缓存 -> 配置inlcude-->
    <!--:include: "组件名数组"-->
    <keep-alive :include="keepArr">
      <router-view></router-view>
    </keep-alive>
  </div>
</template>

<script>
export default {
  name: 'h5-wrapper',
  data() {
    return {
      // 缓存组件名的数组
      keepArr: ['LayoutPage'],
    }
  },
}
</script>
```

### 被缓存的组件会多出两个声明周期钩子

1. actived 激活时，组件被看到时触发

2. deactived 失活时，离开页面组件看不见时触发
   注：一旦组件被缓存，在再次回到被缓存的页面时，Vue 原本的生命周期的八大钩子的一些逻辑就不会被触发，而是用keep-active的两个钩子代替

## 页面访问拦截

路由导航守卫 - 全局前置守卫

### vue2 - 全局前置守卫

1. 所有的路由一旦被匹配到，都会先经过全局前置守卫

2. 只有全局前置守卫放行，才会真正解析渲染组件，才能看到页面内容

   **语法：**

   ```js
   // router.js
   // 所有的路由在被访问到之前（解析渲染对应组件页面），都会先经过全局前置守卫
   // 只有全局前置守卫放行了，才会到达对应的页面

   router.beforeEach((to, from, next) => {
     // 1. to 往哪里去，到哪里去的路由信息对象（路径，参数）
     // 2. form 从哪里来，从哪里来的路由信息对象（路径，参数）
     // 3. next() 是否放行
     //    如果 next() 调用，直接放行，放行到to要去的路径
     //    next(路径) 拦截到next里面配置的路径
   })

   // 例：
   // 定义一个数组，专门存放所有需要权限访问的页面
   const authUrls = ['/pay', '/myorder']

   router.beforeEach((to, from, next) => {
     // console.log(to, from, next)
     // 看 to.path 是否在 authUrls 中出现过
     if (!authUrls.includes(to.path)) {
       // 非权限页面直接放行
       next()
       return
     }

     // 是权限页面，判断 token
     const token = store.getters.token
     if (token) {
       next()
     } else {
       next('/login')
     }
   })
   ```

### vue3 - 全局前置守卫

**语法：**

```js
// 登录访问拦截 → 默认是直接放行的
// 根据返回值决定，是放行还是拦截
// 返回值:
// 1. undefined / true 直接放行
// 2. false 拦回 from 的地址页面
// 3. 具体路径 或 路径对象，拦截到对应的地方
//    '/login'  { name: 'login' }
router.beforeEach((to) => {
  const userStore = useUserStore()
  // 如果没有token，且访问的是非登录页，就拦截到登录
  if (!userStore.token && to.path !== '/login') {
    return '/login'
  }
})
```

## 路由懒加载

**说明：**当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由`被访问的时候才加载对应组件`，这样就更加`高效`了

### 使用步骤

1. 异步组件改造

```js
const proDetail = () => import('@/views/prodetail')
const pay = () => import('@/views/pay')
...
```

2. 路由中应用

```js
const router = new VueRouter({
  routes: [
    ...
    { path: 'prodetail/:id', component: ProDetail },
    { path: '/pay', component: Pay },
    ...
  ]
})
```
